{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Calva is an integrated REPL powered environment for enjoyable and productive Clojure and ClojureScript in Visual Studio Code . It includes inline code evaluation, Paredit, code formatting, a test runner, syntax highlighting, linting , and more. Calva is open source , and free to use. Getting Started First thing you need to do is to get Calva connected to the REPL of your project . Then we suggest you check out Something to Try First . One thing to note about Calva's code formatter is that it sets the default keybinding of the Format Current Form command to tab . Meaning that most often when things look a bit untidy, you can press tab to make things look pretty. Good to know, right? For performance reasons it only formats the current enclosing form, so sometimes you want to move the cursor up/out a form ( ctrl+up ) first. See The Paredit Guide for more on moving the cursor structurally through your code. How to Contribute to Calva? I'm glad you asked! Please see the Calva Development Wiki . (There, in a section labeled The Tao of Calva , we also try to make clear why you would want to contribute.) Have Questions and Feedback? Need Help? Easiest way is to chat with us and other Calva users. Please join the #calva channel on the Clojurians Slack. Happy coding! \u2764\ufe0f","title":"Home"},{"location":"#home","text":"Calva is an integrated REPL powered environment for enjoyable and productive Clojure and ClojureScript in Visual Studio Code . It includes inline code evaluation, Paredit, code formatting, a test runner, syntax highlighting, linting , and more. Calva is open source , and free to use.","title":"Home"},{"location":"#getting-started","text":"First thing you need to do is to get Calva connected to the REPL of your project . Then we suggest you check out Something to Try First . One thing to note about Calva's code formatter is that it sets the default keybinding of the Format Current Form command to tab . Meaning that most often when things look a bit untidy, you can press tab to make things look pretty. Good to know, right? For performance reasons it only formats the current enclosing form, so sometimes you want to move the cursor up/out a form ( ctrl+up ) first. See The Paredit Guide for more on moving the cursor structurally through your code.","title":"Getting Started"},{"location":"#how-to-contribute-to-calva","text":"I'm glad you asked! Please see the Calva Development Wiki . (There, in a section labeled The Tao of Calva , we also try to make clear why you would want to contribute.)","title":"How to Contribute to Calva?"},{"location":"#have-questions-and-feedback-need-help","text":"Easiest way is to chat with us and other Calva users. Please join the #calva channel on the Clojurians Slack. Happy coding! \u2764\ufe0f","title":"Have Questions and Feedback? Need Help?"},{"location":"commands-top10/","text":"The Top 10 Calva Commands There are not all that many Calva commands, you can learn them all. But there are a few anyway and not all commands are created equal. Here are the most important ones to know about for effective Clojure/ClojureScript coding: Grow/expand selection : ctrl+w Load current file : alt+ctrl+c enter , evaluates the namespace code in the active editor tab. This also loads any required namespaces, and generally gives Calva what it needs to work. Evaluate current form : alt+ctrl+c e ( alt+ctrl+c v on Windows), finds the form from the cursor position, evaluates it and displays the result inline. Hit esc to dismiss the results display. Evaluate current top-level form : alt+ctrl+c space : inline evaluate the current top-level form. This also works inside (comment) forms. Use it to (re)define vars and then inside comment forms you can verify that they do what you want them to do. Dismiss the display of results : escape : (VIM Extension users should read Using Calva with the VIM Extension ). The evaluation commands often have an equivalent for when you want to use the REPL window for further exploration. (Basically you add the ctrl+alt modifier to the second chord in the shortcuts): alt+ctrl+c ctrl+alt+e : to evaluate the current form in the REPL window. alt+ctrl+c ctrl+alt+space : to evaluate the current top-level form in this window Load current namespace in the REPL window alt+ctrl+c ctrl+alt+n Toggle pretty printing of results on and off: ctrl+alt+c p . It's on by default. There is a status bar button showing the status and that also can be used to toggle the setting. Some More Commands to Try Code evaluation Evaluate code and add as comment: ctrl+alt+c c (current form), ctrl+alt+c ctrl space (current top level form) Evaluate code and replace it in the editor, inline: ctrl+alt+c r Integrated REPLs Load current namespace in the REPL window: ctrl+alt+c ctrl+alt+n Evaluate current editor form in the REPL window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows) Evaluate current editor top level form in the REPL window: ctrl+alt+c ctrl+space Running tests and mark failures and errors in the Problems pane Run namespace tests: ctrl+alt+c t Run all tests: ctrl+alt+c shift+t Run current test: ctrl+alt+c ctrl+alt+t Rerun previously failing tests: ctrl+alt+c ctrl+t Caveat : Right now the tests are reported only when all are run, making it painful to run all tests in larger projects. I'll fix it. Promise! Select current form: ctrl+alt+c s . Run custom commands, i.e. code snippets, at will: ctrl+alt+c . See also: Code Evaluation Tips Finding Calva Commands and Shortcuts","title":"The Top 10 Calva Commands"},{"location":"commands-top10/#the-top-10-calva-commands","text":"There are not all that many Calva commands, you can learn them all. But there are a few anyway and not all commands are created equal. Here are the most important ones to know about for effective Clojure/ClojureScript coding: Grow/expand selection : ctrl+w Load current file : alt+ctrl+c enter , evaluates the namespace code in the active editor tab. This also loads any required namespaces, and generally gives Calva what it needs to work. Evaluate current form : alt+ctrl+c e ( alt+ctrl+c v on Windows), finds the form from the cursor position, evaluates it and displays the result inline. Hit esc to dismiss the results display. Evaluate current top-level form : alt+ctrl+c space : inline evaluate the current top-level form. This also works inside (comment) forms. Use it to (re)define vars and then inside comment forms you can verify that they do what you want them to do. Dismiss the display of results : escape : (VIM Extension users should read Using Calva with the VIM Extension ). The evaluation commands often have an equivalent for when you want to use the REPL window for further exploration. (Basically you add the ctrl+alt modifier to the second chord in the shortcuts): alt+ctrl+c ctrl+alt+e : to evaluate the current form in the REPL window. alt+ctrl+c ctrl+alt+space : to evaluate the current top-level form in this window Load current namespace in the REPL window alt+ctrl+c ctrl+alt+n Toggle pretty printing of results on and off: ctrl+alt+c p . It's on by default. There is a status bar button showing the status and that also can be used to toggle the setting.","title":"The Top 10 Calva Commands"},{"location":"commands-top10/#some-more-commands-to-try","text":"Code evaluation Evaluate code and add as comment: ctrl+alt+c c (current form), ctrl+alt+c ctrl space (current top level form) Evaluate code and replace it in the editor, inline: ctrl+alt+c r Integrated REPLs Load current namespace in the REPL window: ctrl+alt+c ctrl+alt+n Evaluate current editor form in the REPL window: ctrl+alt+c ctrl+alt+e ( ctrl+alt+c ctrl+alt+v on Windows) Evaluate current editor top level form in the REPL window: ctrl+alt+c ctrl+space Running tests and mark failures and errors in the Problems pane Run namespace tests: ctrl+alt+c t Run all tests: ctrl+alt+c shift+t Run current test: ctrl+alt+c ctrl+alt+t Rerun previously failing tests: ctrl+alt+c ctrl+t Caveat : Right now the tests are reported only when all are run, making it painful to run all tests in larger projects. I'll fix it. Promise! Select current form: ctrl+alt+c s . Run custom commands, i.e. code snippets, at will: ctrl+alt+c . See also: Code Evaluation Tips Finding Calva Commands and Shortcuts","title":"Some More Commands to Try"},{"location":"connect-sequences/","text":"REPL Jack-in and Connection Sequences Many projects grow out of the template phase and call for custom developer workflows involving application start commands, customized REPLs, and what have you. Even some templates add this kind of complexity. To make Jack-in usable for a broader set of projects, Calva has a setting keyed calva.replConnectSequences which lets you configure one ore more connect sequences. NB: Connect sequence configuration affect Calva's Jack-in menu in the following ways: With no sequence configured, Calva will prompt for the built in sequences it has that seems to match your project. With only one custom connect sequence specified, Calva will skip prompting for sequences and use your custom sequence. With more than one sequence specified, Calva will prompt with a menu consisting of these custom sequences. Settings for adding Custom Sequences A connect sequence configures the following: name : (required) This will show up in the Jack-in quick-pick menu when you start Jack-in (see above). projectType : (required) This is either \"Leiningen\u201d, \u201dClojure-CLI\u201d, \u201dshadow-cljs\u201d, \u201dlein-shadow\u201d, or \u201dgeneric\". nReplPortFile : An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be [\".shadow-cljs\", \"nrepl.port\"] . afterCLJReplJackInCode : Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created. cljsType : This can be either \"Figwheel Main\", \"lein-figwheel\", \"shadow-cljs\", \"Nashorn\", or a dictionary configuring a custom type. If omitted, Calva will skip connecting a ClojureScript repl. A custom type has the following fields: dependsOn : (required) Calva will use this to determine which dependencies it will add when starting the project (Jacking in). This can be either \"Figwheel Main\", \"lein-figwheel\", \"shadow-cljs\", \"Nashorn\", or \u201dUser provided\u201d. If it is \"User provided\", then you need to provide the dependencies in the project, or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed. isStarted : Boolean. For CLJS REPLs that Calva does not need to start, set this to true. (If you base your custom cljs repl on a shadow-cljs workflow, for instance.) startCode : Clojure code to be evaluated to create and/or start your custom CLJS REPL. isStartedRegExp : A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated. openUrlRegExp : A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named url . E.g. \"Open URL: (?\\<url>S+)\" shouldOpenUrl : Choose if Calva should automatically open the URL for you or not. connectCode : (required) Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application. (For some setups this could also conditionally start the CLJS REPL. If so: startCode should be omitted.) isConnectedRegExp : (required) A regular expression which, when matched in the stdout from the connectCode evaluation, will tell Calva that the application is connected. The default is To quit, type: :cljs/quit and you should leave it at that unless you know it won't work. printThisLineRegExp : regular expression which, when matched in the stdout from any code evaluations in the cljsType , will make the matched text be printed to the Calva says Output channel. buildsRequired : Boolean. If the repl type requires that builds are started in order to connect to them, set this to true. menuSelections : a dictionary with pre-filled-in selections for the Jack-in and Connect prompts, making Calva not prompt for that particular selection: leinProfiles : At Jack-in to a Leiningen project, use these profiles to launch the repl. leinAlias : At Jack-in to a Leiningen project, launch with this alias. Set to null to launch with Calva's default task (a headless repl), w/o prompting. cljAliases : At Jack-in to a Clojure CLI project, use these aliases to launch the repl. cljsLaunchBuilds : The cljs builds to start/watch at Jack-in/connect. cljsDefaultBuild : Which cljs build to attach to at the initial connect. The Calva built-in sequences also uses this format, check them out to get a clearer picture of how these settings work. Example Sequences Setting for a full-stack application. It starts the backend server when the CLJ REPL has started. Then proceeds to create a custom CLJS REPL (calling in to the application code for this). And then connects to it. { \"calva.replConnectSequences\": [ { \"name\": \"Example Sequence\", \"projectType\": \"Clojure-CLI\", \"afterCLJReplJackInCode\": \"(go)\", \"cljsType\": { \"startCode\": \"(do (require '[cljs-test.main :refer :all])(start-nrepl+fig))\", \"isStartedRegExp\": \"Prompt will show\", \"connectCode\": \"(do (use 'cljs-test.main) (cljs-repl))\", \"isConnectedRegExp\": \"To quit, type: :cljs/quit\", \"printThisLineRegExp\": \"\\\\[Figwheel\\\\] Starting Server at.*\" } } ] } Here is an example from the JUXT Edge project template. It adds two sequences, one for when only the Clojure REPL should be launched and one for when the customized Edge cljs repl should also be connected. The Edge backend + frontend sequence specifies that the web app should be opened by Calva, making cljs repl connection more stable, and also adds menuSelections to skip the launch aliases prompt. { \"calva.replConnectSequences\": [ { \"name\": \"Edge backend only\", \"projectType\": \"Clojure CLI\" }, { \"name\": \"Edge backend + frontend\", \"projectType\": \"Clojure CLI\", \"cljsType\": { \"dependsOn\": \"Figwheel Main\", \"startCode\": \"(do (require 'dev-extras) (dev-extras/go) (println \\\"Edge Figwheel Main started\\\") ((resolve 'dev-extras/cljs-repl)))\", \"isReadyToStartRegExp\": \"Edge Figwheel Main started\", \"openUrlRegExp\": \"Website listening on: (?<url>\\\\S+)\", \"printThisLineRegExp\": \"\\\\[Edge\\\\]\", \"shouldOpenUrl\": true, \"connectCode\": \"(do (require 'dev-extras) ((resolve 'dev-extras/cljs-repl)))\", \"isConnectedRegExp\": \"To quit, type: :cljs/quit\", \"buildsRequired\": false }, \"menuSelections\": { \"cljAliases\": [ \"dev\", \"build\", \"dev/build\" ], } } ] } A Clojure CLI sequence that does not promote the ClojureScript repl at all (leaving it a Clojure REPL), and leaves that up to you to do interactively. (Could be useful while you are developing a custom cljs repl.) The example is for when adapting a Figwheel Main repl. { \"calva.replConnectSequences\": [ { \"name\": \"Do not promote to cljs\", \"projectType\": \"Clojure CLI\", \"cljsType\": { \"dependsOn\": \"Figwheel Main\", \"connectCode\": \"\\\"Don't promote me bro!\\\"\", \"isConnectedRegExp\": \"Don't promote me bro!\" } } ] }","title":"REPL Jack-in and Connection Sequences"},{"location":"connect-sequences/#repl-jack-in-and-connection-sequences","text":"Many projects grow out of the template phase and call for custom developer workflows involving application start commands, customized REPLs, and what have you. Even some templates add this kind of complexity. To make Jack-in usable for a broader set of projects, Calva has a setting keyed calva.replConnectSequences which lets you configure one ore more connect sequences. NB: Connect sequence configuration affect Calva's Jack-in menu in the following ways: With no sequence configured, Calva will prompt for the built in sequences it has that seems to match your project. With only one custom connect sequence specified, Calva will skip prompting for sequences and use your custom sequence. With more than one sequence specified, Calva will prompt with a menu consisting of these custom sequences.","title":"REPL Jack-in and Connection Sequences"},{"location":"connect-sequences/#settings-for-adding-custom-sequences","text":"A connect sequence configures the following: name : (required) This will show up in the Jack-in quick-pick menu when you start Jack-in (see above). projectType : (required) This is either \"Leiningen\u201d, \u201dClojure-CLI\u201d, \u201dshadow-cljs\u201d, \u201dlein-shadow\u201d, or \u201dgeneric\". nReplPortFile : An array of path segments with the project root-relative path to the nREPL port file for this connect sequence. E.g. For shadow-cljs this would be [\".shadow-cljs\", \"nrepl.port\"] . afterCLJReplJackInCode : Here you can give Calva some Clojure code to evaluate in the CLJ REPL, once it has been created. cljsType : This can be either \"Figwheel Main\", \"lein-figwheel\", \"shadow-cljs\", \"Nashorn\", or a dictionary configuring a custom type. If omitted, Calva will skip connecting a ClojureScript repl. A custom type has the following fields: dependsOn : (required) Calva will use this to determine which dependencies it will add when starting the project (Jacking in). This can be either \"Figwheel Main\", \"lein-figwheel\", \"shadow-cljs\", \"Nashorn\", or \u201dUser provided\u201d. If it is \"User provided\", then you need to provide the dependencies in the project, or launch with an alias (deps.edn), profile (Leiningen), or build (shadow-cljs) that provides the dependencies needed. isStarted : Boolean. For CLJS REPLs that Calva does not need to start, set this to true. (If you base your custom cljs repl on a shadow-cljs workflow, for instance.) startCode : Clojure code to be evaluated to create and/or start your custom CLJS REPL. isStartedRegExp : A regular expression which, when matched in the stdout from the startCode evaluation, will make Calva continue with connecting the REPL, and to prompt the user to start the application. If omitted and there is startCode Calva will continue when that code is evaluated. openUrlRegExp : A regular expression, matched against the stdout of cljsType evaluations, for extracting the URL with which the app can be started. The expression should have a capturing group named url . E.g. \"Open URL: (?\\<url>S+)\" shouldOpenUrl : Choose if Calva should automatically open the URL for you or not. connectCode : (required) Clojure code to be evaluated to convert the REPL to a CLJS REPL that Calva can use to connect to the application. (For some setups this could also conditionally start the CLJS REPL. If so: startCode should be omitted.) isConnectedRegExp : (required) A regular expression which, when matched in the stdout from the connectCode evaluation, will tell Calva that the application is connected. The default is To quit, type: :cljs/quit and you should leave it at that unless you know it won't work. printThisLineRegExp : regular expression which, when matched in the stdout from any code evaluations in the cljsType , will make the matched text be printed to the Calva says Output channel. buildsRequired : Boolean. If the repl type requires that builds are started in order to connect to them, set this to true. menuSelections : a dictionary with pre-filled-in selections for the Jack-in and Connect prompts, making Calva not prompt for that particular selection: leinProfiles : At Jack-in to a Leiningen project, use these profiles to launch the repl. leinAlias : At Jack-in to a Leiningen project, launch with this alias. Set to null to launch with Calva's default task (a headless repl), w/o prompting. cljAliases : At Jack-in to a Clojure CLI project, use these aliases to launch the repl. cljsLaunchBuilds : The cljs builds to start/watch at Jack-in/connect. cljsDefaultBuild : Which cljs build to attach to at the initial connect. The Calva built-in sequences also uses this format, check them out to get a clearer picture of how these settings work.","title":"Settings for adding Custom Sequences"},{"location":"connect-sequences/#example-sequences","text":"Setting for a full-stack application. It starts the backend server when the CLJ REPL has started. Then proceeds to create a custom CLJS REPL (calling in to the application code for this). And then connects to it. { \"calva.replConnectSequences\": [ { \"name\": \"Example Sequence\", \"projectType\": \"Clojure-CLI\", \"afterCLJReplJackInCode\": \"(go)\", \"cljsType\": { \"startCode\": \"(do (require '[cljs-test.main :refer :all])(start-nrepl+fig))\", \"isStartedRegExp\": \"Prompt will show\", \"connectCode\": \"(do (use 'cljs-test.main) (cljs-repl))\", \"isConnectedRegExp\": \"To quit, type: :cljs/quit\", \"printThisLineRegExp\": \"\\\\[Figwheel\\\\] Starting Server at.*\" } } ] } Here is an example from the JUXT Edge project template. It adds two sequences, one for when only the Clojure REPL should be launched and one for when the customized Edge cljs repl should also be connected. The Edge backend + frontend sequence specifies that the web app should be opened by Calva, making cljs repl connection more stable, and also adds menuSelections to skip the launch aliases prompt. { \"calva.replConnectSequences\": [ { \"name\": \"Edge backend only\", \"projectType\": \"Clojure CLI\" }, { \"name\": \"Edge backend + frontend\", \"projectType\": \"Clojure CLI\", \"cljsType\": { \"dependsOn\": \"Figwheel Main\", \"startCode\": \"(do (require 'dev-extras) (dev-extras/go) (println \\\"Edge Figwheel Main started\\\") ((resolve 'dev-extras/cljs-repl)))\", \"isReadyToStartRegExp\": \"Edge Figwheel Main started\", \"openUrlRegExp\": \"Website listening on: (?<url>\\\\S+)\", \"printThisLineRegExp\": \"\\\\[Edge\\\\]\", \"shouldOpenUrl\": true, \"connectCode\": \"(do (require 'dev-extras) ((resolve 'dev-extras/cljs-repl)))\", \"isConnectedRegExp\": \"To quit, type: :cljs/quit\", \"buildsRequired\": false }, \"menuSelections\": { \"cljAliases\": [ \"dev\", \"build\", \"dev/build\" ], } } ] } A Clojure CLI sequence that does not promote the ClojureScript repl at all (leaving it a Clojure REPL), and leaves that up to you to do interactively. (Could be useful while you are developing a custom cljs repl.) The example is for when adapting a Figwheel Main repl. { \"calva.replConnectSequences\": [ { \"name\": \"Do not promote to cljs\", \"projectType\": \"Clojure CLI\", \"cljsType\": { \"dependsOn\": \"Figwheel Main\", \"connectCode\": \"\\\"Don't promote me bro!\\\"\", \"isConnectedRegExp\": \"Don't promote me bro!\" } } ] }","title":"Example Sequences"},{"location":"connect/","text":"Connect Calva to Your Project The recommended way is to: Jack-in: Let Calva start the REPL for you This way Calva can make sure it is started with the dependencies needed for a working Clojure and/or ClojureScript session. This is often referred to as Jack in (because that is what it is called in CIDER). Jack-in supports both CLJ and for CLJS, and has built-in configurations for Leiningen , Clojure CLI , and shadow-cljs projects, as well as for the CLJS repl types: Figwheel Main , lein-figwheel (legacy Figwheel), shadow-cljs , and Nashorn. Using jack-in provides your development environment with all the dependencies you need for Calva to work. It works like so: Open your project root directory in VS Code. Issue the command Start a Project REPL and Connect : ctrl+alt+c ctrl+alt+j . Answer the quick-pick prompts telling Calva about project types and what profiles to start. See also: Workspace Layouts Aliases, profiles, builds When Jack-in starts it will depend on the project type, and whether ClojureScript is involved or not, and if it is, what kind of ClojureScript project, what will happen next. Calva will analyze the project files and will then give you prompts with selections based on what is found there. You will need some basic knowledge about the project and the project type terminologies to answer the prompts. There are ways to tell Calva the answers to these prompts beforehand, so that Jack-in can be a zero-prompting command. Read on. Customizing Jack-in The main mechanism for customizing your Jack-in, including automating menu selections, and custom CLJS REPL types is Custom Connect Sequences . There are also these settings: * calva.jackInEnv : An object with environment variables that will be added to the environment of the Jack-in process. * calva.myCljAliases : An array of deps.edn aliases not found in the project file. Use this to launch your REPL using your user defined aliases. * calva.myLeinProfiles : An array of Leiningen profiles not found in project.clj . Use adding your user defined profiles to Jack-in launch of the REPL. * calva.openBrowserWhenFigwheelStarted : For Legacy Figwheel only. A boolean controlling if Calva should automatically launch your ClojureScript app, once it is compiled by Figwheel. Defaults to true . Troubleshooting I'm sure there are troubles we should mention here... Connecting w/o Jack-in If, for whatever reasons, you can't use Jack-in with your project (possibly because the REPL is started as part of some other job) all is not lost. Old fashioned Connect to a running REPL is still there for you. For all features to work in Calva while connecting to a running REPL, your environment needs to have REPL related dependencies set up. However, just as before it can be tricky to get the dependencies right. Consider using Jack in to inform yourself on how to start your REPL to Calva's satisfaction. When you use Jack in, Calva starts a VS Code task for it and the command line used is displayed in the terminal pane used to handle the task. Reading that command line tells you what dependencies are needed for your project. Even better: Copying that command line gives you the command to start the REPL with the correct dependencies. All this said, I still recommend you challenge the conclusion that you can't use Jack-in.","title":"Connect Calva to Your Project"},{"location":"connect/#connect-calva-to-your-project","text":"The recommended way is to:","title":"Connect Calva to Your Project"},{"location":"connect/#jack-in-let-calva-start-the-repl-for-you","text":"This way Calva can make sure it is started with the dependencies needed for a working Clojure and/or ClojureScript session. This is often referred to as Jack in (because that is what it is called in CIDER). Jack-in supports both CLJ and for CLJS, and has built-in configurations for Leiningen , Clojure CLI , and shadow-cljs projects, as well as for the CLJS repl types: Figwheel Main , lein-figwheel (legacy Figwheel), shadow-cljs , and Nashorn. Using jack-in provides your development environment with all the dependencies you need for Calva to work. It works like so: Open your project root directory in VS Code. Issue the command Start a Project REPL and Connect : ctrl+alt+c ctrl+alt+j . Answer the quick-pick prompts telling Calva about project types and what profiles to start. See also: Workspace Layouts","title":"Jack-in: Let Calva start the REPL for you"},{"location":"connect/#aliases-profiles-builds","text":"When Jack-in starts it will depend on the project type, and whether ClojureScript is involved or not, and if it is, what kind of ClojureScript project, what will happen next. Calva will analyze the project files and will then give you prompts with selections based on what is found there. You will need some basic knowledge about the project and the project type terminologies to answer the prompts. There are ways to tell Calva the answers to these prompts beforehand, so that Jack-in can be a zero-prompting command. Read on.","title":"Aliases, profiles, builds"},{"location":"connect/#customizing-jack-in","text":"The main mechanism for customizing your Jack-in, including automating menu selections, and custom CLJS REPL types is Custom Connect Sequences . There are also these settings: * calva.jackInEnv : An object with environment variables that will be added to the environment of the Jack-in process. * calva.myCljAliases : An array of deps.edn aliases not found in the project file. Use this to launch your REPL using your user defined aliases. * calva.myLeinProfiles : An array of Leiningen profiles not found in project.clj . Use adding your user defined profiles to Jack-in launch of the REPL. * calva.openBrowserWhenFigwheelStarted : For Legacy Figwheel only. A boolean controlling if Calva should automatically launch your ClojureScript app, once it is compiled by Figwheel. Defaults to true .","title":"Customizing Jack-in"},{"location":"connect/#troubleshooting","text":"I'm sure there are troubles we should mention here...","title":"Troubleshooting"},{"location":"connect/#connecting-wo-jack-in","text":"If, for whatever reasons, you can't use Jack-in with your project (possibly because the REPL is started as part of some other job) all is not lost. Old fashioned Connect to a running REPL is still there for you. For all features to work in Calva while connecting to a running REPL, your environment needs to have REPL related dependencies set up. However, just as before it can be tricky to get the dependencies right. Consider using Jack in to inform yourself on how to start your REPL to Calva's satisfaction. When you use Jack in, Calva starts a VS Code task for it and the command line used is displayed in the terminal pane used to handle the task. Reading that command line tells you what dependencies are needed for your project. Even better: Copying that command line gives you the command to start the REPL with the correct dependencies. All this said, I still recommend you challenge the conclusion that you can't use Jack-in.","title":"Connecting w/o Jack-in"},{"location":"custom-commands/","text":"Running Custom REPL Commands Calva supports configuration of custom command snippets that you can execute in the REPL at will. If your workflow has you repeatedly evaluate a particular piece of code, you can use the setting calva.customREPLCommandSnippets to configure it and then use the command Run Custom REPL Command to access it. The command will give you a menu with the snippets you have configured. The calva.customREPLCommandSnippets is an object/dictionary with the following fields: name : The name of the snippet as it will appear in the picker menu snippet : The code that will be evaluated ns : (optional) Namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current editor. replType : Which REPL window to use for the evaluation. Either \"clj\" or \"cljs\" E.g. with these settings: \"calva.customREPLCommandSnippets\": [ { \"name\": \"Foo\", \"snippet\": \"(println :foo)\", \"ns\": \"acme.test.foo-test\", \"repl\": \"cljs\" }, { \"name\": \"Bar\", \"snippet\": \"(println :bar)\", \"ns\": \"acme.test.bar-test\", \"repl\": \"clj\" }, { \"name\": \"Refresh\", \"snippet\": \"(refresh)\", \"repl\": \"clj\" } ] You will get this menu. The items are numbered for you so that you can choose them in predictable way. The default keyboard shortcut for the command is ctrl + alt + c , . . Which means that to execute the Refresh command, (refresh) , in the clj REPL, you could do: ctrl + alt + c , . , 3 , ENTER .","title":"Running Custom REPL Commands"},{"location":"custom-commands/#running-custom-repl-commands","text":"Calva supports configuration of custom command snippets that you can execute in the REPL at will. If your workflow has you repeatedly evaluate a particular piece of code, you can use the setting calva.customREPLCommandSnippets to configure it and then use the command Run Custom REPL Command to access it. The command will give you a menu with the snippets you have configured. The calva.customREPLCommandSnippets is an object/dictionary with the following fields: name : The name of the snippet as it will appear in the picker menu snippet : The code that will be evaluated ns : (optional) Namespace to evaluate the command in. If omitted the command will be executed in the namespace of the current editor. replType : Which REPL window to use for the evaluation. Either \"clj\" or \"cljs\" E.g. with these settings: \"calva.customREPLCommandSnippets\": [ { \"name\": \"Foo\", \"snippet\": \"(println :foo)\", \"ns\": \"acme.test.foo-test\", \"repl\": \"cljs\" }, { \"name\": \"Bar\", \"snippet\": \"(println :bar)\", \"ns\": \"acme.test.bar-test\", \"repl\": \"clj\" }, { \"name\": \"Refresh\", \"snippet\": \"(refresh)\", \"repl\": \"clj\" } ] You will get this menu. The items are numbered for you so that you can choose them in predictable way. The default keyboard shortcut for the command is ctrl + alt + c , . . Which means that to execute the Refresh command, (refresh) , in the clj REPL, you could do: ctrl + alt + c , . , 3 , ENTER .","title":"Running Custom REPL Commands"},{"location":"customizing/","text":"Customizing Calva Don't like the defaults? On this page we can collect some of the customizations that people have done, and maybe write a thing or two about it some day. Tip For VS Code newcomers: The search box in Settings is your friend. Also, some Calva settings are more complex than the Settings UI can handle. VS Code will then show you a link to settings.json . And VS Code's built-in json extension is awesome. To add settings for, say Calva's Pretty Printing, search for \u201dprettyprint\u201d in VS Code Settings and follow the link to settings.json . Start typing \u201dcalvapretty\u201d until auto-complete suggests calva.prettyPrintingOptions . Press ENTER and VS Code will fill in these defaults: \"calva.prettyPrintingOptions\": { \"enabled\": true, \"printEngine\": \"pprint\", \"width\": 40 }, Clojure Defaults Calva sets some VS Code settings for all Clojure files. Some of these are needed for Calva to function correctly, which should not be tampered with unless you really know what you are doing, and some of them are for convenience defaults. If you add a setting to your settings.json and accept the snippet help you get when you type \"[clojure]\" , you will get the Calva defaults pasted: \"[clojure]\": { \"editor.wordSeparators\": \"\\t ()\\\"':,;~@#$%^&{}[]`\", \"editor.autoClosingBrackets\": \"always\", \"editor.autoClosingQuotes\": \"always\", \"editor.formatOnType\": true, \"editor.autoIndent\": \"full\", \"editor.formatOnPaste\": true, \"files.trimTrailingWhitespace\": false, \"editor.matchBrackets\": \"never\", \"editor.parameterHints.enabled\": false } Automatic Parmaeter Hints Poppup Calva has helpful parameter hints to aid when typing function calls. They look like so: To have the hints automatically pop up when you are typing, set editor.parameterHints.enabled to true in the above [clojure] scoped setting. (To call them up on demand the default VS Code keybindings are cmd+shift+space on Mac and ctrl+shift+space on Linux/Windows.) Code Formatting See [Formatting] for information on how to configure this. Jack-in and Connect Sequences Jack-in and Connect are very customizable through Custom Connect Sequences . The REPL Window If you don't want the REPL window to open automatically on jack-in/connect, set calva.openREPLWindowOnConnect to false . Please note, that if the Connect Sequence you are using has afterCLJReplJackInCode , then the CLJ REPL window will open anyway in order to evaluate that code for you in a visible way. Default Key Bindings The REPL Window prompt is a multi line editor, and the keyboard shortcuts facilitate this by default. The shortcuts can be configured however you like, and there are two preconfigured maps for it as well. You set this via the calva.REPLWindowPromptKeyMap setting: Prompt command multi-line single-line Submit alt+enter enter New line enter alt+enter Cursor Up up alt+up Cursor Down down alt+down History Up alt+up up History Down alt+down down As you might see, the simple pattern here is that in multi-line mode you move the cursor and enter new lines as in the regular editor, and use alt modifier to navigate the history and submit evaluations. In single-line mode it is the other way around. Pretty Printing Calva's pretty printing mode can be configured a bit. See Pretty Printing . Calva Highlight Calva takes care of syntax highlighting, and also provides some features not available through VS Code's highlighting mechanism. These extras include rainbow parens, sane bracket matching, and comment form dimming/highlighting. You are in charge of how brackets and comments are highlighted via the calva.highlight.<setting> settings: Setting Meaning Example enableBracketColors Enable rainbow colors true bracketColors Which colors to use [\"#000\", \"#999\"] cycleBracketColors Whether same colors should be reused for deeply nested brackets true misplacedBracketStyle Style of misplaced bracket { \"border\": \"2px solid #c33\" } matchedBracketStyle Style of bracket pair highlight {\"backgroundColor\": \"#E0E0E0\"} ignoredFormStyle Style of #_... form {\"textDecoration\": \"none; opacity: 0.5\"} commentFormStyle Style of (comment ...) form {\"fontStyle\": \"italic\"} The extras are built from Clojure Warrior , created by Nikita Prokopov, a.k.a. @tonsky 's. Please note that the default styling for (comment ...) forms now is to italicize them (instead of dimming). This is to promote using comment forms to work with the REPL. Key bindings These key binds replace the default Calva \u201dprefix\u201d, ctrl+alt+c to just alt+v : WebWItch's keybindings.json (Please note, that alt+v does not work for some locales, but for when it works it is much less clunky than the default prefix). Here the Calva key is switched for ctrl+, : manas_marthi's keybindings Keybindings for Emacs users Are you a vim extension user? See: Using with VIM extension . Paredit Please be aware that the REPL window does not handle chorded shortcuts. Something to keep in mind when customizing Paredit shortcuts, because those are dispatched onto the REPL window. So, best to avoid chorded shortcuts for Paredit. Wrap using ( , [ , { (like Cursive) Something I use in IntelliJ/Cursive is the ability to select an expression and hit one of ( , [ , { to wrap it. And after wrapping the expression I don't want the selection anymore, so if I were wrapping (foo) then I would want to get ( | (foo)) where | would be my cursor. Here's how you can make this work with Calva Paredit: Update all of the Paredit: Wrap Around ... commands so that their respective shortcuts are the wrappers themselves and update the when clause to include editorHasSelection (otherwise when you open a paren and the next expression would get slurped in). The change would look like this in your keybindings.json : { \"key\": \"shift+9\", \"command\": \"paredit.wrapAroundParens\", \"when\": \"editorTextFocus && editorHasSelection && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"[\", \"command\": \"paredit.wrapAroundSquare\", \"when\": \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+[\", \"command\": \"paredit.wrapAroundCurly\", \"when\": \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }","title":"Customizing Calva"},{"location":"customizing/#customizing-calva","text":"Don't like the defaults? On this page we can collect some of the customizations that people have done, and maybe write a thing or two about it some day. Tip For VS Code newcomers: The search box in Settings is your friend. Also, some Calva settings are more complex than the Settings UI can handle. VS Code will then show you a link to settings.json . And VS Code's built-in json extension is awesome. To add settings for, say Calva's Pretty Printing, search for \u201dprettyprint\u201d in VS Code Settings and follow the link to settings.json . Start typing \u201dcalvapretty\u201d until auto-complete suggests calva.prettyPrintingOptions . Press ENTER and VS Code will fill in these defaults: \"calva.prettyPrintingOptions\": { \"enabled\": true, \"printEngine\": \"pprint\", \"width\": 40 },","title":"Customizing Calva"},{"location":"customizing/#clojure-defaults","text":"Calva sets some VS Code settings for all Clojure files. Some of these are needed for Calva to function correctly, which should not be tampered with unless you really know what you are doing, and some of them are for convenience defaults. If you add a setting to your settings.json and accept the snippet help you get when you type \"[clojure]\" , you will get the Calva defaults pasted: \"[clojure]\": { \"editor.wordSeparators\": \"\\t ()\\\"':,;~@#$%^&{}[]`\", \"editor.autoClosingBrackets\": \"always\", \"editor.autoClosingQuotes\": \"always\", \"editor.formatOnType\": true, \"editor.autoIndent\": \"full\", \"editor.formatOnPaste\": true, \"files.trimTrailingWhitespace\": false, \"editor.matchBrackets\": \"never\", \"editor.parameterHints.enabled\": false }","title":"Clojure Defaults"},{"location":"customizing/#automatic-parmaeter-hints-poppup","text":"Calva has helpful parameter hints to aid when typing function calls. They look like so: To have the hints automatically pop up when you are typing, set editor.parameterHints.enabled to true in the above [clojure] scoped setting. (To call them up on demand the default VS Code keybindings are cmd+shift+space on Mac and ctrl+shift+space on Linux/Windows.)","title":"Automatic Parmaeter Hints Poppup"},{"location":"customizing/#code-formatting","text":"See [Formatting] for information on how to configure this.","title":"Code Formatting"},{"location":"customizing/#jack-in-and-connect-sequences","text":"Jack-in and Connect are very customizable through Custom Connect Sequences .","title":"Jack-in and Connect Sequences"},{"location":"customizing/#the-repl-window","text":"If you don't want the REPL window to open automatically on jack-in/connect, set calva.openREPLWindowOnConnect to false . Please note, that if the Connect Sequence you are using has afterCLJReplJackInCode , then the CLJ REPL window will open anyway in order to evaluate that code for you in a visible way.","title":"The REPL Window"},{"location":"customizing/#default-key-bindings","text":"The REPL Window prompt is a multi line editor, and the keyboard shortcuts facilitate this by default. The shortcuts can be configured however you like, and there are two preconfigured maps for it as well. You set this via the calva.REPLWindowPromptKeyMap setting: Prompt command multi-line single-line Submit alt+enter enter New line enter alt+enter Cursor Up up alt+up Cursor Down down alt+down History Up alt+up up History Down alt+down down As you might see, the simple pattern here is that in multi-line mode you move the cursor and enter new lines as in the regular editor, and use alt modifier to navigate the history and submit evaluations. In single-line mode it is the other way around.","title":"Default Key Bindings"},{"location":"customizing/#pretty-printing","text":"Calva's pretty printing mode can be configured a bit. See Pretty Printing .","title":"Pretty Printing"},{"location":"customizing/#calva-highlight","text":"Calva takes care of syntax highlighting, and also provides some features not available through VS Code's highlighting mechanism. These extras include rainbow parens, sane bracket matching, and comment form dimming/highlighting. You are in charge of how brackets and comments are highlighted via the calva.highlight.<setting> settings: Setting Meaning Example enableBracketColors Enable rainbow colors true bracketColors Which colors to use [\"#000\", \"#999\"] cycleBracketColors Whether same colors should be reused for deeply nested brackets true misplacedBracketStyle Style of misplaced bracket { \"border\": \"2px solid #c33\" } matchedBracketStyle Style of bracket pair highlight {\"backgroundColor\": \"#E0E0E0\"} ignoredFormStyle Style of #_... form {\"textDecoration\": \"none; opacity: 0.5\"} commentFormStyle Style of (comment ...) form {\"fontStyle\": \"italic\"} The extras are built from Clojure Warrior , created by Nikita Prokopov, a.k.a. @tonsky 's. Please note that the default styling for (comment ...) forms now is to italicize them (instead of dimming). This is to promote using comment forms to work with the REPL.","title":"Calva Highlight"},{"location":"customizing/#key-bindings","text":"These key binds replace the default Calva \u201dprefix\u201d, ctrl+alt+c to just alt+v : WebWItch's keybindings.json (Please note, that alt+v does not work for some locales, but for when it works it is much less clunky than the default prefix). Here the Calva key is switched for ctrl+, : manas_marthi's keybindings Keybindings for Emacs users Are you a vim extension user? See: Using with VIM extension .","title":"Key bindings"},{"location":"customizing/#paredit","text":"Please be aware that the REPL window does not handle chorded shortcuts. Something to keep in mind when customizing Paredit shortcuts, because those are dispatched onto the REPL window. So, best to avoid chorded shortcuts for Paredit.","title":"Paredit"},{"location":"customizing/#wrap-using-like-cursive","text":"Something I use in IntelliJ/Cursive is the ability to select an expression and hit one of ( , [ , { to wrap it. And after wrapping the expression I don't want the selection anymore, so if I were wrapping (foo) then I would want to get ( | (foo)) where | would be my cursor. Here's how you can make this work with Calva Paredit: Update all of the Paredit: Wrap Around ... commands so that their respective shortcuts are the wrappers themselves and update the when clause to include editorHasSelection (otherwise when you open a paren and the next expression would get slurped in). The change would look like this in your keybindings.json : { \"key\": \"shift+9\", \"command\": \"paredit.wrapAroundParens\", \"when\": \"editorTextFocus && editorHasSelection && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"[\", \"command\": \"paredit.wrapAroundSquare\", \"when\": \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+[\", \"command\": \"paredit.wrapAroundCurly\", \"when\": \"editorHasSelection && editorTextFocus && !editorReadOnly && editorLangId =~ /clojure|scheme|lisp/ && paredit:keyMap =~ /original|strict/\" }","title":"Wrap using (, [, { (like Cursive)"},{"location":"debugger/","text":"Debugger Calva's debugger allows you to place breapoints via reader tags so that execution will pause at those locations. During paused execution, you can see the value of local variables in the side pane, as well as evaluate code within the local context - via the editor or the repl-window, just as you normally would evaluate code. The debugger is in an early release stage. Some functionality does not yet work. See the features section for details. Note: The debugger currently does not support ClojureScript. Calva's debugger utilizes cider-nrepl for debugging. See this Cider issue for more information. Using the Debugger Setting Breakpoints with #break You can insert a breakpoint manually into any code by placing a #break in front of the form where you want execution to pause, and then evaluating the top level form with ctrl+alt+c space . When you evaluate a call to this code the VS Code debugger will start, the cursor will move to right after the form that's preceded by #break , and the line will be highlighted so show execution is paused there. Note: Code will be executed up to and including the form preceding the cursor. You can also set conditional breapoints by adding metadata before the form that the #break applies to. Instrumenting a Function with #dbg Adding #dbg before a function definition then evaluating the top-level form with ctrl+alt+c space will instrument the function, meaning breakpoints will be added in places where it makes sense. When you evaluate a call to this function, execution will pause wherever breakpoints were added. These breakpoints are not visible in the editor. If you notice execution does not pause, it's likely that no reasonable place was found to place a breakpoint. Evaluating Code in the Paused Context When execution is paused at a breakpoint, you can evaluate code in that context. This can be done in the editor or in the REPL window, as usual. In the REPL window, the prompt changes to <<debug-mode>>=> to show that evaluations will occur in the debug context. Viewing Variable Values While Debugging While debugging, you can view the values of variables in VS Code's debugger side pane. You can also view values by hovering over the variables in the editor. Currently, values for collections and maps are shown as strings, but we plan to make them structured in the future. For now, if you want to see the value of a large structured variable, you can evaluate the variable, either from the editor or from the REPL window. Navigation You can use VS Code's debugger UI to navigate while debugging. Currently only the continue functionality is implemented, but in the future step over, step into, and step out will be implemented as well. Clicking the step buttons currently does nothing. Also, clicking restart does nothing, since this functionality does not make sense for our debugger. Features Current Set breakpoints with #break Instrument functions with #dbg Continue to next breakpoint Evaluate code in the debug context See variable values in the debugger side pane See variable values on hover in the editor Upcoming Step over form Step into form Step out of form See structured variables in the debugger side pane (currently maps and collections are just shown as strings)","title":"Debugger"},{"location":"debugger/#debugger","text":"Calva's debugger allows you to place breapoints via reader tags so that execution will pause at those locations. During paused execution, you can see the value of local variables in the side pane, as well as evaluate code within the local context - via the editor or the repl-window, just as you normally would evaluate code. The debugger is in an early release stage. Some functionality does not yet work. See the features section for details. Note: The debugger currently does not support ClojureScript. Calva's debugger utilizes cider-nrepl for debugging. See this Cider issue for more information.","title":"Debugger"},{"location":"debugger/#using-the-debugger","text":"","title":"Using the Debugger"},{"location":"debugger/#setting-breakpoints-with-break","text":"You can insert a breakpoint manually into any code by placing a #break in front of the form where you want execution to pause, and then evaluating the top level form with ctrl+alt+c space . When you evaluate a call to this code the VS Code debugger will start, the cursor will move to right after the form that's preceded by #break , and the line will be highlighted so show execution is paused there. Note: Code will be executed up to and including the form preceding the cursor. You can also set conditional breapoints by adding metadata before the form that the #break applies to.","title":"Setting Breakpoints with #break"},{"location":"debugger/#instrumenting-a-function-with-dbg","text":"Adding #dbg before a function definition then evaluating the top-level form with ctrl+alt+c space will instrument the function, meaning breakpoints will be added in places where it makes sense. When you evaluate a call to this function, execution will pause wherever breakpoints were added. These breakpoints are not visible in the editor. If you notice execution does not pause, it's likely that no reasonable place was found to place a breakpoint.","title":"Instrumenting a Function with #dbg"},{"location":"debugger/#evaluating-code-in-the-paused-context","text":"When execution is paused at a breakpoint, you can evaluate code in that context. This can be done in the editor or in the REPL window, as usual. In the REPL window, the prompt changes to <<debug-mode>>=> to show that evaluations will occur in the debug context.","title":"Evaluating Code in the Paused Context"},{"location":"debugger/#viewing-variable-values-while-debugging","text":"While debugging, you can view the values of variables in VS Code's debugger side pane. You can also view values by hovering over the variables in the editor. Currently, values for collections and maps are shown as strings, but we plan to make them structured in the future. For now, if you want to see the value of a large structured variable, you can evaluate the variable, either from the editor or from the REPL window.","title":"Viewing Variable Values While Debugging"},{"location":"debugger/#navigation","text":"You can use VS Code's debugger UI to navigate while debugging. Currently only the continue functionality is implemented, but in the future step over, step into, and step out will be implemented as well. Clicking the step buttons currently does nothing. Also, clicking restart does nothing, since this functionality does not make sense for our debugger.","title":"Navigation"},{"location":"debugger/#features","text":"","title":"Features"},{"location":"debugger/#current","text":"Set breakpoints with #break Instrument functions with #dbg Continue to next breakpoint Evaluate code in the debug context See variable values in the debugger side pane See variable values on hover in the editor","title":"Current"},{"location":"debugger/#upcoming","text":"Step over form Step into form Step out of form See structured variables in the debugger side pane (currently maps and collections are just shown as strings)","title":"Upcoming"},{"location":"emacs-keybindings/","text":"Emacs Keybindings Some keybindings to make it easier for Emacs users [ { \"key\": \"ctrl+cmd+b\", \"command\": \"paredit.backwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+left\", \"command\": \"-paredit.backwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+cmd+]\", \"command\": \"-workbench.action.nextEditor\" }, { \"key\": \"ctrl+shift+]\", \"command\": \"paredit.barfSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+right\", \"command\": \"-paredit.barfSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+[\", \"command\": \"paredit.barfSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+left\", \"command\": \"-paredit.barfSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+f\", \"command\": \"paredit.forwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+right\", \"command\": \"-paredit.forwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+f\", \"command\": \"-workbench.action.toggleFullScreen\" }, { \"key\": \"ctrl+shift+backspace\", \"command\": \"-paredit.killSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+cmd+k\", \"command\": \"-editor.action.deleteLines\", \"when\": \"textInputFocus && !editorReadonly\" }, { \"key\": \"ctrl+shift+0\", \"command\": \"paredit.slurpSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+right\", \"command\": \"-paredit.slurpSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+9\", \"command\": \"paredit.slurpSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+left\", \"command\": \"-paredit.slurpSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+c ctrl+c\", \"command\": \"calva.evaluateCurrentTopLevelForm\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+alt+c space\", \"command\": \"-calva.evaluateCurrentTopLevelForm\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+x ctrl+e\", \"command\": \"calva.evalCurrentTopLevelFormInREPLWindow\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+alt+c ctrl+alt+space\", \"command\": \"-calva.evalCurrentTopLevelFormInREPLWindow\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+x ctrl+s\", \"command\": \"workbench.action.files.save\" }, { \"key\": \"cmd+s\", \"command\": \"-workbench.action.files.save\" }, { \"key\": \"cmd+s\", \"command\": \"paredit.spliceSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+s\", \"command\": \"-paredit.spliceSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+k\", \"command\": \"paredit.cutForwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+x right\", \"command\": \"-paredit.cutForwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+backspace\", \"command\": \"paredit.cutBackwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+x left\", \"command\": \"-paredit.cutBackwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+1\", \"command\": \"-workbench.action.openEditorAtIndex1\" }, { \"key\": \"ctrl+1\", \"command\": \"editor.action.quickFix\", \"when\": \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\": \"cmd+.\", \"command\": \"-editor.action.quickFix\", \"when\": \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\": \"cmd+.\", \"command\": \"editor.action.revealDefinition\", \"when\": \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" }, { \"key\": \"f12\", \"command\": \"-editor.action.revealDefinition\", \"when\": \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" } ]","title":"Emacs Keybindings"},{"location":"emacs-keybindings/#emacs-keybindings","text":"Some keybindings to make it easier for Emacs users [ { \"key\": \"ctrl+cmd+b\", \"command\": \"paredit.backwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+left\", \"command\": \"-paredit.backwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+cmd+]\", \"command\": \"-workbench.action.nextEditor\" }, { \"key\": \"ctrl+shift+]\", \"command\": \"paredit.barfSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+right\", \"command\": \"-paredit.barfSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+[\", \"command\": \"paredit.barfSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+left\", \"command\": \"-paredit.barfSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+f\", \"command\": \"paredit.forwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+right\", \"command\": \"-paredit.forwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+f\", \"command\": \"-workbench.action.toggleFullScreen\" }, { \"key\": \"ctrl+shift+backspace\", \"command\": \"-paredit.killSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"shift+cmd+k\", \"command\": \"-editor.action.deleteLines\", \"when\": \"textInputFocus && !editorReadonly\" }, { \"key\": \"ctrl+shift+0\", \"command\": \"paredit.slurpSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+right\", \"command\": \"-paredit.slurpSexpForward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+9\", \"command\": \"paredit.slurpSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+left\", \"command\": \"-paredit.slurpSexpBackward\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+c ctrl+c\", \"command\": \"calva.evaluateCurrentTopLevelForm\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+alt+c space\", \"command\": \"-calva.evaluateCurrentTopLevelForm\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+x ctrl+e\", \"command\": \"calva.evalCurrentTopLevelFormInREPLWindow\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+alt+c ctrl+alt+space\", \"command\": \"-calva.evalCurrentTopLevelFormInREPLWindow\", \"when\": \"calva:activated\" }, { \"key\": \"ctrl+x ctrl+s\", \"command\": \"workbench.action.files.save\" }, { \"key\": \"cmd+s\", \"command\": \"-workbench.action.files.save\" }, { \"key\": \"cmd+s\", \"command\": \"paredit.spliceSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+alt+s\", \"command\": \"-paredit.spliceSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+k\", \"command\": \"paredit.cutForwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+x right\", \"command\": \"-paredit.cutForwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+cmd+backspace\", \"command\": \"paredit.cutBackwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+shift+x left\", \"command\": \"-paredit.cutBackwardSexp\", \"when\": \"calva:activated && calva:pareditValid && paredit:keyMap =~ /original|strict/\" }, { \"key\": \"ctrl+1\", \"command\": \"-workbench.action.openEditorAtIndex1\" }, { \"key\": \"ctrl+1\", \"command\": \"editor.action.quickFix\", \"when\": \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\": \"cmd+.\", \"command\": \"-editor.action.quickFix\", \"when\": \"editorHasCodeActionsProvider && editorTextFocus && !editorReadonly\" }, { \"key\": \"cmd+.\", \"command\": \"editor.action.revealDefinition\", \"when\": \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" }, { \"key\": \"f12\", \"command\": \"-editor.action.revealDefinition\", \"when\": \"editorHasDefinitionProvider && editorTextFocus && !isInEmbeddedEditor\" } ]","title":"Emacs Keybindings"},{"location":"eval-tips/","text":"Code Evaluation Tips Calva tries to make it easy to evaluate code, supporting interactive development. NB: The below assumes you have read about Finding Calva Commands and Shortcuts . There are some different \u201dflavors\u201d to the evaluation. And it depends on if you are evaluating in a file editor or a in a REPL window. Evaluation in a File Editor Calva has commands for evaluating the current form and the current top-level form . You can also choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. You find the full results in the hover of the eveluated form , from where it is easy to copy it to the clipboard. (The results will also get printed to the Calva says output channel.) To comments. This will add the results as comment lines below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results. Send to REPL window. You can also send the current form, or current top-level form, to the REPL window for evaluation. This is currently the only way to get a readable and clickable stack trace in cases where evaluation results in such errors. Wait, Current Form? Top-level Form? These are important concepts in Calva in order for you to create your most effective workflow. Current Form The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides). Current Top-level Form The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, but it can be any form not enclosed in any other form. An exception is the comment form. It will create a new top level context, so that any forms immediatlly inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow where you Iterate on your functions. Evaluate the function (top level). Put them to test with expressions inside a comment form. Repeat from 1. , until the function does what you want it to do. Here's a demo of the last repetition of such a workflow, for a simple implementation of the abs function: Copying the inline results The easiest way is to use the Copy button in the result hover. There is also the Copy last evaluation results command, ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window. Evaluating in a REPL window To evaluate code in the REPL window either send a form from the editor (as mentioned above) or type it at the prompt and submit it. There is also a repl history that you can access with alt+up/down . Note that the repl prompt is a multiline mini Clojure editor. So if you press enter while the cursor is not at the end of the line, it will create a new line. To submit the code at the prompt you have three options: Place the cursor at the end of the all the code, end ( fn+right on Macs lacking an end key). Press alt+enter . This submits and prints the results un-altered. See also above about sending forms from the file editors to the REPL window for evaluation.","title":"Code Evaluation Tips"},{"location":"eval-tips/#code-evaluation-tips","text":"Calva tries to make it easy to evaluate code, supporting interactive development. NB: The below assumes you have read about Finding Calva Commands and Shortcuts . There are some different \u201dflavors\u201d to the evaluation. And it depends on if you are evaluating in a file editor or a in a REPL window.","title":"Code Evaluation Tips"},{"location":"eval-tips/#evaluation-in-a-file-editor","text":"Calva has commands for evaluating the current form and the current top-level form . You can also choose what should happen with the results: Inline. This will display the results (or some of it, if it is long) inline in the editor. You find the full results in the hover of the eveluated form , from where it is easy to copy it to the clipboard. (The results will also get printed to the Calva says output channel.) To comments. This will add the results as comment lines below the current line. Replace the evaluated code. This will do what it says, the evaluated code will be replaced with its results. Send to REPL window. You can also send the current form, or current top-level form, to the REPL window for evaluation. This is currently the only way to get a readable and clickable stack trace in cases where evaluation results in such errors.","title":"Evaluation in a File Editor"},{"location":"eval-tips/#wait-current-form-top-level-form","text":"These are important concepts in Calva in order for you to create your most effective workflow.","title":"Wait, Current Form? Top-level Form?"},{"location":"eval-tips/#current-form","text":"The current form either means the current selection, or otherwise is based on the cursor position. Play some with the command Calva: Select current form , ctrl+alt+c s , to figure out what Calva thinks is the current form for some different situations. Try it inside a symbol, adjacent to a symbol (both sides) and adjacent to an opening or closing bracket (again, both sides).","title":"Current Form"},{"location":"eval-tips/#current-top-level-form","text":"The current top-level form means top-level in a structural sense. It is not the topmost form in the file. Typically in a Clojure file you will find def and defn (and defwhatever ) forms at the top level, but it can be any form not enclosed in any other form. An exception is the comment form. It will create a new top level context, so that any forms immediatlly inside a (commment ...) form will be considered top-level by Calva. This is to support a workflow where you Iterate on your functions. Evaluate the function (top level). Put them to test with expressions inside a comment form. Repeat from 1. , until the function does what you want it to do. Here's a demo of the last repetition of such a workflow, for a simple implementation of the abs function:","title":"Current Top-level Form"},{"location":"eval-tips/#copying-the-inline-results","text":"The easiest way is to use the Copy button in the result hover. There is also the Copy last evaluation results command, ctrl+alt+c ctrl+c . This works regardless if you have evaluated in a file editor or in a REPL window.","title":"Copying the inline results"},{"location":"eval-tips/#evaluating-in-a-repl-window","text":"To evaluate code in the REPL window either send a form from the editor (as mentioned above) or type it at the prompt and submit it. There is also a repl history that you can access with alt+up/down . Note that the repl prompt is a multiline mini Clojure editor. So if you press enter while the cursor is not at the end of the line, it will create a new line. To submit the code at the prompt you have three options: Place the cursor at the end of the all the code, end ( fn+right on Macs lacking an end key). Press alt+enter . This submits and prints the results un-altered. See also above about sending forms from the file editors to the REPL window for evaluation.","title":"Evaluating in a REPL window"},{"location":"finding-commands/","text":"Finding Calva Commands Calva relies a lot on that VS Code makes it really easy to find commands by opening the command palette: ctrl+shift+p (Windows/Linux), cmd+shift+p (Mac), and then start typing some words (or part of words) that you think might be in the command. To leverage this, all Calva commands are prefixed with Calva . As an example, say you want to evaluate a form and pretty print it. Then you can do this: Open the command palette Type calevpr VS Code will match cal to \u201d Cal va\u201d, ev to \u201d Ev aluate\u201d, and pr to \u201d pr etty\u201d in \u201d pr etty print\u201d. It looks like so: As you can see on the screenshot, VS Code will also reveal the keyboard shortcut for the command. My advice is to make it a habit to try to remember those shortcuts and use them for a more effective workflow. Now might be a good time to see Calva Top 10 Commands All the Settings and Commands Did you know? There is a complete list of Calva settings and commands in the Contributions tab of the Calva entry in the Extensions pane in VS Code.","title":"Finding Calva Commands"},{"location":"finding-commands/#finding-calva-commands","text":"Calva relies a lot on that VS Code makes it really easy to find commands by opening the command palette: ctrl+shift+p (Windows/Linux), cmd+shift+p (Mac), and then start typing some words (or part of words) that you think might be in the command. To leverage this, all Calva commands are prefixed with Calva . As an example, say you want to evaluate a form and pretty print it. Then you can do this: Open the command palette Type calevpr VS Code will match cal to \u201d Cal va\u201d, ev to \u201d Ev aluate\u201d, and pr to \u201d pr etty\u201d in \u201d pr etty print\u201d. It looks like so: As you can see on the screenshot, VS Code will also reveal the keyboard shortcut for the command. My advice is to make it a habit to try to remember those shortcuts and use them for a more effective workflow. Now might be a good time to see Calva Top 10 Commands","title":"Finding Calva Commands"},{"location":"finding-commands/#all-the-settings-and-commands","text":"Did you know? There is a complete list of Calva settings and commands in the Contributions tab of the Calva entry in the Extensions pane in VS Code.","title":"All the Settings and Commands"},{"location":"formatting/","text":"Formatting We have tried to make Calva's formatter so that it just works . It is enabled by default for Clojure files, and unconfigured it mostly follows Bozhidar Batsov's Clojure Style Guide . Calva uses cljfmt for the formatting. With the default settings, Calva's formatting behaves like so: formats as you type (when entering new lines) formats the current enclosing form when you hit tab formats pasted code formats according to community standards (see above link) formats the current form, aligning map key, values , when you press ctrl+alt+l . Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files. Calva's formatting is mostly about indenting, but it also (again, defaults): trims whitespace at the end of the line trims whitespace inside brackets this also folds trailing brackets (a k a the paren trail ) up on the same line inserts whitespace between forms Not a fan of some default setting? The formatter is quite configurable. ## Configuration You configure Calva's formatting using cljfmt's configuration EDN . This means that you can adjust the above mentioned defaults, including the indenting. NB: The cljfmt docs mention the :cljfmt config key of Leiningen projects. Calva does not yet read the config from there, so if your Leiningen project has such a configuration, you will need to copy it out into a file. To start changing the defaults, paste the following map into a file and save it. It could be somewhere in the project workspace, or some other place, dependig on your requirements: {:remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? true :align-associative? false} Then set calva.fmt.configPath to the path to the file. The path should either be absolute, or relative to the project root directory. So, if you named the file .cljfmt.edn and saved it in the root of the project, then this setting should be .cljfmt.edn . Since you are editing the file in Calva (you are, right?), you can quickly test how different settings affect the formatting. Try: setting :align-associative to true then save then hit tab , and see what happens. (This particular setting is experimental and known to cause trouble together with namespaced keywords. Consider using ctrl+alt+l instead of tab as your formatting command, instead of enabling this setting.) NB: The hot reloading of the config file does only work for files inside the project directory structure. Indentation rules The cljfmt indents are highly configurable. They, and the rest of the configuration options, are masterly detailed here . Calva is an extra good tool for experimenting with these settings. cljfmt doesn't care about keys in the map that it doesn't now about so you can sneak in test code there to quickly see how it will get formatted by certain rules. Try this, for instance: {:remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? false :align-associative? false :indents ^:replace {#\"^\\w\" [[:inner 0]]} :test-code (concat [2] (map #(inc (* % 2)) (filter #(aget sieved %) (range 1 hn))))} Save, then hit tab , and the code should get formatted like so: :test-code (concat [2] (map #(inc (* % 2)) (filter #(aget sieved %) (range 1 hn)))) That's somewhat similar to Nikita Prokopov's Better Clojure Formatting suggestion. (Please be aware that this setting might not be sufficient to get complete Tonsky Formatting , please share any settings you do to get full compliance.) Under Construction Much of this formatting configurability is recent work. There might be dragons. And also, we probably should make Calva pick the :cljfmt config up from Leiningen project files. If you agree, and there isn't an issue about that already, please file one.","title":"Formatting"},{"location":"formatting/#formatting","text":"We have tried to make Calva's formatter so that it just works . It is enabled by default for Clojure files, and unconfigured it mostly follows Bozhidar Batsov's Clojure Style Guide . Calva uses cljfmt for the formatting. With the default settings, Calva's formatting behaves like so: formats as you type (when entering new lines) formats the current enclosing form when you hit tab formats pasted code formats according to community standards (see above link) formats the current form, aligning map key, values , when you press ctrl+alt+l . Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files. Calva's formatting is mostly about indenting, but it also (again, defaults): trims whitespace at the end of the line trims whitespace inside brackets this also folds trailing brackets (a k a the paren trail ) up on the same line inserts whitespace between forms Not a fan of some default setting? The formatter is quite configurable. ## Configuration You configure Calva's formatting using cljfmt's configuration EDN . This means that you can adjust the above mentioned defaults, including the indenting. NB: The cljfmt docs mention the :cljfmt config key of Leiningen projects. Calva does not yet read the config from there, so if your Leiningen project has such a configuration, you will need to copy it out into a file. To start changing the defaults, paste the following map into a file and save it. It could be somewhere in the project workspace, or some other place, dependig on your requirements: {:remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? true :align-associative? false} Then set calva.fmt.configPath to the path to the file. The path should either be absolute, or relative to the project root directory. So, if you named the file .cljfmt.edn and saved it in the root of the project, then this setting should be .cljfmt.edn . Since you are editing the file in Calva (you are, right?), you can quickly test how different settings affect the formatting. Try: setting :align-associative to true then save then hit tab , and see what happens. (This particular setting is experimental and known to cause trouble together with namespaced keywords. Consider using ctrl+alt+l instead of tab as your formatting command, instead of enabling this setting.) NB: The hot reloading of the config file does only work for files inside the project directory structure.","title":"Formatting"},{"location":"formatting/#indentation-rules","text":"The cljfmt indents are highly configurable. They, and the rest of the configuration options, are masterly detailed here . Calva is an extra good tool for experimenting with these settings. cljfmt doesn't care about keys in the map that it doesn't now about so you can sneak in test code there to quickly see how it will get formatted by certain rules. Try this, for instance: {:remove-surrounding-whitespace? true :remove-trailing-whitespace? true :remove-consecutive-blank-lines? false :insert-missing-whitespace? false :align-associative? false :indents ^:replace {#\"^\\w\" [[:inner 0]]} :test-code (concat [2] (map #(inc (* % 2)) (filter #(aget sieved %) (range 1 hn))))} Save, then hit tab , and the code should get formatted like so: :test-code (concat [2] (map #(inc (* % 2)) (filter #(aget sieved %) (range 1 hn)))) That's somewhat similar to Nikita Prokopov's Better Clojure Formatting suggestion. (Please be aware that this setting might not be sufficient to get complete Tonsky Formatting , please share any settings you do to get full compliance.)","title":"Indentation rules"},{"location":"formatting/#under-construction","text":"Much of this formatting configurability is recent work. There might be dragons. And also, we probably should make Calva pick the :cljfmt config up from Leiningen project files. If you agree, and there isn't an issue about that already, please file one.","title":"Under Construction"},{"location":"jack-in-guide/","text":"Learn about Calva Jack-in The Calva Jack-In Academy, by @pez Like with CIDER Jack-in , Calva's let-me-help-you-start-your-project-and-connect feature might seem a bit mysterious. It really is helpful, but also really isn't mysterious. Here are a few things about it that is good to know about. What it Solves At first it might seem that something like lein repl in a terminal and then connecting Calva is enough. It sometimes might be, but only if you are in luck. To provide many of its IDE features, Calva relies on nREPL middleware, mainly cider-nrepl and, for ClojureScript, piggieback . When starting your Clojure(Script) app and its REPL, it needs to be started with these dependencies satisfied. There are mainly three ways this can be achieved. In the project definition (files like project.clj , deps.edn , shadow-cljs.edn , and combination of these). In your user profile (files like ~/.lein/profiles.clj and ~/.clojure/deps.edn ). On the command line. Because 1 and 2 are hard to keep in sync with the various editor environment people in your project might be using, Calva Jack-In is about 3 . Ideally, you will be able to rid your project files completely of editor dependencies, when people working on the project can rely on the Jack-In features of their Clojure editor. A Controlled Shell Command At its core Calva Jack-In is just a glorified, REPL-starting, command-line. No, it is more than that, but anyway. The command line can look like so for a Leiningen project using legacy Figwheel for its ClojureScript assistance: lein update-in :dependencies conj '[nrepl\"0.6.0\"]' -- update-in :dependencies conj '[cider/piggieback\"0.4.1\"]' -- update-in :dependencies conj '[figwheel-sidecar\"0.5.18\"]' -- update-in :plugins conj '[cider/cider-nrepl\"0.22.4\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.piggieback/wrap-cljs-repl\"]' -- with-profile +dev repl :headless Even if a bit long, it might look simple enough. But actually it has taken quite some effort to make Calva craft it. Shell quoting can be really tricky. Look at how '[nrepl\"0.6.0\"]' doesn't have a space between nrepl and the version. That was the only way I could find that was cross platform enough to make all supported shells parse the command line. (The trick relies on that the string is read by the super reliable Clojure Reader, which does not need that space to tokenize it.) It is awesome that Clojure is used on so many platforms, but for a tool smith this also means more work. (I think Windows and its shell hell ate up about 95% of the many hours spent on getting the quoting good enough.) The command-line crafted is then used to start a shell command that Calva controls, but we are getting ahead of ourselves... Project Types, Builds, Aliases, Profiles, etcetera In order to cook the right command for your project, Calva looks for project files, reads them, and figures out what possible project types and ClojureScript tools could be involved. Then Calva presents you with a menu with the options it has found. You need to know enough about your project to answer this question. It looks like this in a shadow-cljs project that uses a deps.edn file for setting up its classpath. (I know enough about this particular project to know that I should choose the shadow-cljs project type.) But Calva isn't ready to cook the command-line just yet, depending on the project type, and contents of your project files, more info is needed. E.g. in the case of shadow-cljs projects, Calva needs to know what builds to start. Here you can select any combination of builds defined in the project, and Calva will cook a command line that starts them. You might get more prompts from Calva before it issues the command, but for this example project, Calva goes ahead, cooks the command line, and issues it. On my Mac, it looks like so: npx shadow-cljs -d cider/piggieback:0.4.1 -d cider/cider-nrepl:0.22.4 watch :app (Much shorter than the one with lein-figwheel, right? It is because shadow-cljs is aware of CIDER dependencies, so doesn't need as many dependencies specified as some other project types do.) Connecting When the command is issued Calva needs to wait until the REPL Server is started, before connecting to it, and possibly continuing with starting a ClojureScript REPL and connect to that as well. It also needs to know which port to connect to. Because reasons, Calva can't yet read the stdout of the shell command it has issued, so to know when the REPL server is started, and on which port, Calva monitors the filesystem for the .nrepl-port file. (This file is not always named like that. shadow-cljs, for instance, creates the file .shadow-cljs/nrepl.port .) When the port file is created, Calva picks up the port number from it and connects to the nREPL server. At this point you have a Clojure REPL backing your Calva session, providing all sorts of nice IDE help for you. Starting Your Clojure App Once you have the Clojure REPL connected you can start your Clojure app/server. See Custom Connect Sequences for how to let Calva do this for you automatically. See the same article for ways to automate more of the Jack-in process. It can be brought down to a single Jack-In command, even for a full stack Clojure and ClojureScript application. ClojureScript For ClojureScript, things are not done yet, though, far from it. It turns out that cooking the command line was the easy part. In order for Calva to provide REPL power for ClojureScript projects, several things need to happen: A Clojure nREPL connection needs to be established. We've covered that above. Calva makes an nREPL session clone to use for the ClojureScript REPL and then: Your ClojureScript app needs to be compiled. Your ClojureScript app needs to be started. The Clojure nREPL session needs to be promoted to a ClojureScript nREPL session. (This is what piggieback helps with.) (It's also possible to connect Calva directly to a Nashorn, bare nodejs, or browser REPL, but let's stick to the scenario where you get a REPL into your running application.) Compiling the App and Watchers Depending on ClojureScript project type, Calva uses different methods to start the compilation and the watcher: Figwheel: The compilation and the watchers are started in the Clojure REPL session. (This is both for Figwheel Main and for lein-figwheel.) shadow-cljs: The compilation and the watchers are started with the Jack-In command line. This results in a bit of difference in the user interaction. Mainly that for shadow-cljs, the user needs to check the Jack-In Terminal tab to follow what's going on. Starting the App Number 1.2 above, the app needs to be started , might seem obvious, but it actually trips many people up. Because of this, Calva goes to quite some lengths to provide assistance. Many projects are configured not to spawn a browser session automatically, requesting the app once it has been compiled, so we can't rely on that. What Calva does instead is to monitor the output of the commands it uses for starting the compilation, looking for information that the app is ready to be requested/started. It then tells the user this, providing a URL, in case it is a browser app. (There are also settings where you can ask Calva to open the URL automatically for you, regardless what the project settings are.) Connecting Meanwhile, Calva is monitoring the output and when it sees that the app is started, it continues to hook up the REPL connection to the editor. This whole connection sequence is quite configurable, using Custom Connect Sequences . In fact, Calva's built in ClojureScript sequences (Figwheel Main, lein-figwheel, shadow-cljs, and Nashorn) are all built using those same settings mechanisms. shadow-cljs is Less Managed by Calva NB: The managed way in which Calva creates and connects the ClojureScript REPL breaks apart a bit for shadow-cljs, which works a bit differently and also outputs most of the information Calva is looking for on the stdout of the REPL start command (where Calva can't see it, remember?). We'll figure out a better way to support shadow-cljs, but for now, the user needs to do more of this figuring out, than is needed with Figwheel projects. Hack Away So, there are things going on when you start Jack-In, and even more things for ClojureScript projects, but Calva tries to keep it together, so as a user it is a matter of paying attention and responding to a few prompts/menus with pre-populated options. (Prompts which can be configured away, even.) Switch ClojureScript Builds Once the REPL is connected you might want to change which ClojureScript build you have Calva connected to. For this Calva has the Select CLJS Build Connection command. Please note that you can only switch between builds that you have started. Play with Starting the cljs-repl Yourself To get a good grip on what is going on when creating and connecting the ClojureScript REPL, I can recommend making a custom connect sequence which leaves the REPL unpromoted (e.g. give it nil as connectCode ), and then evaluate the cljs-repl start commands yourself. So for instance, promoting it to a Nashorn ClojureScript REPL looks something like so: user=> (require 'cljs.repl.nashorn) user=> (cider.piggieback/cljs-repl (cljs.repl.nashorn/repl-env)) ClojureScript 1.10.145 To quit, type: :cljs/quit nil cljs.user=> | It is the piggieback middleware there telling you that you can unpromote the REPL by \u201devaluating\u201d :cljs/quit . About Full Stack Applications Because Calva uses the Clojure REPL connection to spawn the ClojureScript REPL, and because Calva only handles one Clojure REPL per VS Code window, some projects need special handling by the user. If your full stack project is using shadow-cljs for the frontend, like this Fulcro template project does, maybe you first try Jack-In to your backend Clojure REPL, and then to your shadow-cljs frontend. This works if you do it in separate VS Code windows, but if you do it in the same window, the second Jack-In will kill the backend session! See also about Workspace Layouts for tips about how to actually open the same project folder in two separate VS Code windows. Please Grab your Calva Jack-In Certificate There, you now know all there is to know about Calva Jack-in. Just kidding, there are a few more details to it, some of which might find their way into this article at a later time. To really get to know it all, you will need to spend some time with the Calva Jack-In code. Head over to the Calva Development Wiki to learn how to hack on Calva.","title":"Learn about Calva Jack-in"},{"location":"jack-in-guide/#learn-about-calva-jack-in","text":"The Calva Jack-In Academy, by @pez Like with CIDER Jack-in , Calva's let-me-help-you-start-your-project-and-connect feature might seem a bit mysterious. It really is helpful, but also really isn't mysterious. Here are a few things about it that is good to know about.","title":"Learn about Calva Jack-in"},{"location":"jack-in-guide/#what-it-solves","text":"At first it might seem that something like lein repl in a terminal and then connecting Calva is enough. It sometimes might be, but only if you are in luck. To provide many of its IDE features, Calva relies on nREPL middleware, mainly cider-nrepl and, for ClojureScript, piggieback . When starting your Clojure(Script) app and its REPL, it needs to be started with these dependencies satisfied. There are mainly three ways this can be achieved. In the project definition (files like project.clj , deps.edn , shadow-cljs.edn , and combination of these). In your user profile (files like ~/.lein/profiles.clj and ~/.clojure/deps.edn ). On the command line. Because 1 and 2 are hard to keep in sync with the various editor environment people in your project might be using, Calva Jack-In is about 3 . Ideally, you will be able to rid your project files completely of editor dependencies, when people working on the project can rely on the Jack-In features of their Clojure editor.","title":"What it Solves"},{"location":"jack-in-guide/#a-controlled-shell-command","text":"At its core Calva Jack-In is just a glorified, REPL-starting, command-line. No, it is more than that, but anyway. The command line can look like so for a Leiningen project using legacy Figwheel for its ClojureScript assistance: lein update-in :dependencies conj '[nrepl\"0.6.0\"]' -- update-in :dependencies conj '[cider/piggieback\"0.4.1\"]' -- update-in :dependencies conj '[figwheel-sidecar\"0.5.18\"]' -- update-in :plugins conj '[cider/cider-nrepl\"0.22.4\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.nrepl/cider-middleware\"]' -- update-in '[:repl-options :nrepl-middleware]' conj '[\"cider.piggieback/wrap-cljs-repl\"]' -- with-profile +dev repl :headless Even if a bit long, it might look simple enough. But actually it has taken quite some effort to make Calva craft it. Shell quoting can be really tricky. Look at how '[nrepl\"0.6.0\"]' doesn't have a space between nrepl and the version. That was the only way I could find that was cross platform enough to make all supported shells parse the command line. (The trick relies on that the string is read by the super reliable Clojure Reader, which does not need that space to tokenize it.) It is awesome that Clojure is used on so many platforms, but for a tool smith this also means more work. (I think Windows and its shell hell ate up about 95% of the many hours spent on getting the quoting good enough.) The command-line crafted is then used to start a shell command that Calva controls, but we are getting ahead of ourselves...","title":"A Controlled Shell Command"},{"location":"jack-in-guide/#project-types-builds-aliases-profiles-etcetera","text":"In order to cook the right command for your project, Calva looks for project files, reads them, and figures out what possible project types and ClojureScript tools could be involved. Then Calva presents you with a menu with the options it has found. You need to know enough about your project to answer this question. It looks like this in a shadow-cljs project that uses a deps.edn file for setting up its classpath. (I know enough about this particular project to know that I should choose the shadow-cljs project type.) But Calva isn't ready to cook the command-line just yet, depending on the project type, and contents of your project files, more info is needed. E.g. in the case of shadow-cljs projects, Calva needs to know what builds to start. Here you can select any combination of builds defined in the project, and Calva will cook a command line that starts them. You might get more prompts from Calva before it issues the command, but for this example project, Calva goes ahead, cooks the command line, and issues it. On my Mac, it looks like so: npx shadow-cljs -d cider/piggieback:0.4.1 -d cider/cider-nrepl:0.22.4 watch :app (Much shorter than the one with lein-figwheel, right? It is because shadow-cljs is aware of CIDER dependencies, so doesn't need as many dependencies specified as some other project types do.)","title":"Project Types, Builds, Aliases, Profiles, etcetera"},{"location":"jack-in-guide/#connecting","text":"When the command is issued Calva needs to wait until the REPL Server is started, before connecting to it, and possibly continuing with starting a ClojureScript REPL and connect to that as well. It also needs to know which port to connect to. Because reasons, Calva can't yet read the stdout of the shell command it has issued, so to know when the REPL server is started, and on which port, Calva monitors the filesystem for the .nrepl-port file. (This file is not always named like that. shadow-cljs, for instance, creates the file .shadow-cljs/nrepl.port .) When the port file is created, Calva picks up the port number from it and connects to the nREPL server. At this point you have a Clojure REPL backing your Calva session, providing all sorts of nice IDE help for you.","title":"Connecting"},{"location":"jack-in-guide/#starting-your-clojure-app","text":"Once you have the Clojure REPL connected you can start your Clojure app/server. See Custom Connect Sequences for how to let Calva do this for you automatically. See the same article for ways to automate more of the Jack-in process. It can be brought down to a single Jack-In command, even for a full stack Clojure and ClojureScript application.","title":"Starting Your Clojure App"},{"location":"jack-in-guide/#clojurescript","text":"For ClojureScript, things are not done yet, though, far from it. It turns out that cooking the command line was the easy part. In order for Calva to provide REPL power for ClojureScript projects, several things need to happen: A Clojure nREPL connection needs to be established. We've covered that above. Calva makes an nREPL session clone to use for the ClojureScript REPL and then: Your ClojureScript app needs to be compiled. Your ClojureScript app needs to be started. The Clojure nREPL session needs to be promoted to a ClojureScript nREPL session. (This is what piggieback helps with.) (It's also possible to connect Calva directly to a Nashorn, bare nodejs, or browser REPL, but let's stick to the scenario where you get a REPL into your running application.)","title":"ClojureScript"},{"location":"jack-in-guide/#compiling-the-app-and-watchers","text":"Depending on ClojureScript project type, Calva uses different methods to start the compilation and the watcher: Figwheel: The compilation and the watchers are started in the Clojure REPL session. (This is both for Figwheel Main and for lein-figwheel.) shadow-cljs: The compilation and the watchers are started with the Jack-In command line. This results in a bit of difference in the user interaction. Mainly that for shadow-cljs, the user needs to check the Jack-In Terminal tab to follow what's going on.","title":"Compiling the App and Watchers"},{"location":"jack-in-guide/#starting-the-app","text":"Number 1.2 above, the app needs to be started , might seem obvious, but it actually trips many people up. Because of this, Calva goes to quite some lengths to provide assistance. Many projects are configured not to spawn a browser session automatically, requesting the app once it has been compiled, so we can't rely on that. What Calva does instead is to monitor the output of the commands it uses for starting the compilation, looking for information that the app is ready to be requested/started. It then tells the user this, providing a URL, in case it is a browser app. (There are also settings where you can ask Calva to open the URL automatically for you, regardless what the project settings are.)","title":"Starting the App"},{"location":"jack-in-guide/#connecting_1","text":"Meanwhile, Calva is monitoring the output and when it sees that the app is started, it continues to hook up the REPL connection to the editor. This whole connection sequence is quite configurable, using Custom Connect Sequences . In fact, Calva's built in ClojureScript sequences (Figwheel Main, lein-figwheel, shadow-cljs, and Nashorn) are all built using those same settings mechanisms.","title":"Connecting"},{"location":"jack-in-guide/#shadow-cljs-is-less-managed-by-calva","text":"NB: The managed way in which Calva creates and connects the ClojureScript REPL breaks apart a bit for shadow-cljs, which works a bit differently and also outputs most of the information Calva is looking for on the stdout of the REPL start command (where Calva can't see it, remember?). We'll figure out a better way to support shadow-cljs, but for now, the user needs to do more of this figuring out, than is needed with Figwheel projects.","title":"shadow-cljs is Less Managed by Calva"},{"location":"jack-in-guide/#hack-away","text":"So, there are things going on when you start Jack-In, and even more things for ClojureScript projects, but Calva tries to keep it together, so as a user it is a matter of paying attention and responding to a few prompts/menus with pre-populated options. (Prompts which can be configured away, even.)","title":"Hack Away"},{"location":"jack-in-guide/#switch-clojurescript-builds","text":"Once the REPL is connected you might want to change which ClojureScript build you have Calva connected to. For this Calva has the Select CLJS Build Connection command. Please note that you can only switch between builds that you have started.","title":"Switch ClojureScript Builds"},{"location":"jack-in-guide/#play-with-starting-the-cljs-repl-yourself","text":"To get a good grip on what is going on when creating and connecting the ClojureScript REPL, I can recommend making a custom connect sequence which leaves the REPL unpromoted (e.g. give it nil as connectCode ), and then evaluate the cljs-repl start commands yourself. So for instance, promoting it to a Nashorn ClojureScript REPL looks something like so: user=> (require 'cljs.repl.nashorn) user=> (cider.piggieback/cljs-repl (cljs.repl.nashorn/repl-env)) ClojureScript 1.10.145 To quit, type: :cljs/quit nil cljs.user=> | It is the piggieback middleware there telling you that you can unpromote the REPL by \u201devaluating\u201d :cljs/quit .","title":"Play with Starting the cljs-repl Yourself"},{"location":"jack-in-guide/#about-full-stack-applications","text":"Because Calva uses the Clojure REPL connection to spawn the ClojureScript REPL, and because Calva only handles one Clojure REPL per VS Code window, some projects need special handling by the user. If your full stack project is using shadow-cljs for the frontend, like this Fulcro template project does, maybe you first try Jack-In to your backend Clojure REPL, and then to your shadow-cljs frontend. This works if you do it in separate VS Code windows, but if you do it in the same window, the second Jack-In will kill the backend session! See also about Workspace Layouts for tips about how to actually open the same project folder in two separate VS Code windows.","title":"About Full Stack Applications"},{"location":"jack-in-guide/#please-grab-your-calva-jack-in-certificate","text":"There, you now know all there is to know about Calva Jack-in. Just kidding, there are a few more details to it, some of which might find their way into this article at a later time. To really get to know it all, you will need to spend some time with the Calva Jack-In code. Head over to the Calva Development Wiki to learn how to hack on Calva.","title":"Please Grab your Calva Jack-In Certificate"},{"location":"linting/","text":"Linting Calva does no linting, yet with Calva you get excellent linting. That is because Calva bundles the clj-kondo extension, which is powered by the linter with the same name . You might want to read about how to configure clj-kondo . These two sections might be of extra interest: * Exclude unresolved symbols from being reported * Lint a custom macro like a built-in macro If you see clj-kondo squiggle the first character of the file with an error you don't quite understand, it is probably something wrong with your clj-kondo configuration. The clj-kondo extension lints the current file as it is being edited. If you want to lint the whole project, use the clj-kondo cli command. See https://github.com/borkdude/clj-kondo for more info on that. Windows users might like to know that they too can get a clj-kondo cli command now, via npm install -g clj-kondo . It'll be a bit slower to start than the native build, but for sure it's better than not having a clj-kondo command! (Besides, the VS Code extension takes care of the cases where you really want speed.) See https://github.com/borkdude/clj-kondo/blob/master/doc/install.md#npm-linux-macos-windows for more on this.","title":"Linting"},{"location":"linting/#linting","text":"Calva does no linting, yet with Calva you get excellent linting. That is because Calva bundles the clj-kondo extension, which is powered by the linter with the same name . You might want to read about how to configure clj-kondo . These two sections might be of extra interest: * Exclude unresolved symbols from being reported * Lint a custom macro like a built-in macro If you see clj-kondo squiggle the first character of the file with an error you don't quite understand, it is probably something wrong with your clj-kondo configuration. The clj-kondo extension lints the current file as it is being edited. If you want to lint the whole project, use the clj-kondo cli command. See https://github.com/borkdude/clj-kondo for more info on that. Windows users might like to know that they too can get a clj-kondo cli command now, via npm install -g clj-kondo . It'll be a bit slower to start than the native build, but for sure it's better than not having a clj-kondo command! (Besides, the VS Code extension takes care of the cases where you really want speed.) See https://github.com/borkdude/clj-kondo/blob/master/doc/install.md#npm-linux-macos-windows for more on this.","title":"Linting"},{"location":"luminus/","text":"How to Use Calva with Luminus Luminus is a powerful and versitle Leiningen template for creating web development projects. It comes with built in configuration for making it easy to use Calva as your Clojure(Script) editor. Server + shadow-cljs Basically this is the same wokflow as with Server only . Behind the scenes there is more happening, though. Such as the ClojureScript app being built and the CLJS REPL connected once the web app is running. If you haven't created the project yet, create a new shadow-cljs Luminus project. E.g.: sh $ lein new luminus my-luminus-shadow +reagent +shadow-cljs This creates the folder my-luminus-shadow . Open it in VS Code: sh $ code my-luminus-shadow Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start Server + Client \u2013 my-luminus-shadow , and wait for the Terminal Calva Jack-in output to say [:app] Build completed. Open 127.0.0.1:3000 in your web browser and start hacking. Note: Currently Calva has troubles following the app-start with shadow-cljs, so Calva will report Jack-in done. in the Calva says output before shadow-cljs is actually done building the app. If you open the app page at that stage, you will see a message to \u201d Please run lein shadow watch app \u201d. Rest assured that this is already underway. Follow the Jack-in process in the Terminal tab in VS Code for the message that the app is built, then reload the app page in the web browser. Server Only The workflow here is really just: Jack-in and start hacking. The first time it involves these steps, however: If you haven't created the project yet, create a new server only Luminus project. For a all-defaults setup it is like so: sh $ lein new luminus my-luminus-server This creates the folder my-luminus-server . Open it in VS Code: sh $ code my-luminus-server Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j and wait for the Calva says output to say Jack-in done. Open 127.0.0.1:3000 in your web browser and start hacking. Server + Figwheel This is Legacy Fighwheel (lein-figwheel), so the recommendation is to use the shadow-cljs setup instead. As with the server only, the workflow here is really just: Jack-in and start hacking. The first time it involves these steps: If you haven't created the project yet, create a new server only Luminus project. E.g.: sh $ lein new luminus my-fw +reagent This creates the folder my-fw . Open it in VS Code: sh $ code my-fw Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j , select Server + Client - my-fw in the Project type picker menu, and wait for the web app to pop open in your web browser. Start hacking. If you rather open the web app yourself, open .vscode/settings.json and change \"shouldOpenUrl\" to false in the preconfigured Calva connect sequence. Calva will then print the URL 127.0.0.1:3000 in the output, so that you can click it open. Etcetera You will have three Calva Custom Command Snippets configured. Invoke them by issuing the Run Custom REPL Command , ctrl+alt+c . (that's a dot). The commands control the Luminus server: Start <project> Server Stop <project> Server Restart <project> Server When used, Calva will open its REPL window and excute the command, if it is not already opened. You can close this window if you prefer to use the REPL directly from the Clojure files. Calva also opens the REPL window, and starts the Luminus server, as part of the Jack-in process.","title":"How to Use Calva with Luminus"},{"location":"luminus/#how-to-use-calva-with-luminus","text":"Luminus is a powerful and versitle Leiningen template for creating web development projects. It comes with built in configuration for making it easy to use Calva as your Clojure(Script) editor.","title":"How to Use Calva with Luminus"},{"location":"luminus/#server-shadow-cljs","text":"Basically this is the same wokflow as with Server only . Behind the scenes there is more happening, though. Such as the ClojureScript app being built and the CLJS REPL connected once the web app is running. If you haven't created the project yet, create a new shadow-cljs Luminus project. E.g.: sh $ lein new luminus my-luminus-shadow +reagent +shadow-cljs This creates the folder my-luminus-shadow . Open it in VS Code: sh $ code my-luminus-shadow Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j Select to start Server + Client \u2013 my-luminus-shadow , and wait for the Terminal Calva Jack-in output to say [:app] Build completed. Open 127.0.0.1:3000 in your web browser and start hacking. Note: Currently Calva has troubles following the app-start with shadow-cljs, so Calva will report Jack-in done. in the Calva says output before shadow-cljs is actually done building the app. If you open the app page at that stage, you will see a message to \u201d Please run lein shadow watch app \u201d. Rest assured that this is already underway. Follow the Jack-in process in the Terminal tab in VS Code for the message that the app is built, then reload the app page in the web browser.","title":"Server + shadow-cljs"},{"location":"luminus/#server-only","text":"The workflow here is really just: Jack-in and start hacking. The first time it involves these steps, however: If you haven't created the project yet, create a new server only Luminus project. For a all-defaults setup it is like so: sh $ lein new luminus my-luminus-server This creates the folder my-luminus-server . Open it in VS Code: sh $ code my-luminus-server Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j and wait for the Calva says output to say Jack-in done. Open 127.0.0.1:3000 in your web browser and start hacking.","title":"Server Only"},{"location":"luminus/#server-figwheel","text":"This is Legacy Fighwheel (lein-figwheel), so the recommendation is to use the shadow-cljs setup instead. As with the server only, the workflow here is really just: Jack-in and start hacking. The first time it involves these steps: If you haven't created the project yet, create a new server only Luminus project. E.g.: sh $ lein new luminus my-fw +reagent This creates the folder my-fw . Open it in VS Code: sh $ code my-fw Use the Calva command Start a Project REPL and Connect (aka Jack-in) : ctrl+alt+c ctrl+alt+j , select Server + Client - my-fw in the Project type picker menu, and wait for the web app to pop open in your web browser. Start hacking. If you rather open the web app yourself, open .vscode/settings.json and change \"shouldOpenUrl\" to false in the preconfigured Calva connect sequence. Calva will then print the URL 127.0.0.1:3000 in the output, so that you can click it open.","title":"Server + Figwheel"},{"location":"luminus/#etcetera","text":"You will have three Calva Custom Command Snippets configured. Invoke them by issuing the Run Custom REPL Command , ctrl+alt+c . (that's a dot). The commands control the Luminus server: Start <project> Server Stop <project> Server Restart <project> Server When used, Calva will open its REPL window and excute the command, if it is not already opened. You can close this window if you prefer to use the REPL directly from the Clojure files. Calva also opens the REPL window, and starts the Luminus server, as part of the Jack-in process.","title":"Etcetera"},{"location":"paredit/","text":"Paredit \u2013 a Visual Guide Structural editing and navigation for Clojure. What is Paredit? Calva Paredit helps you navigate, select and edit Clojure code in a structural way. LISP isn't line or character oriented, it is based around S-expressions , a.k.a forms. We strongly recommend that you take advantage of the structural nature of Clojure, and have therefore put a lot of work into making Calva Paredit extra awesome. If you are new to Paredit, consider starting with learning the Slurp Forward (pull in the next form into this form) and Barf Forward (push the last form out of this form). It will take you quite far. Strict Mode To protect the integrity of your code, Strict mode is enabled by default. Strict mode keybinding Action Description backspace Delete Backward Deletes one character backwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it will remove both open and close brackets. delete Delete Forward Deletes one character forwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it is removed. alt+backspace Force Delete Backward Deletes one character backwards, even if it will unbalance a form. alt+delete Force Delete Forward Deletes one character forwards, even if it will unbalance a form. Disable at your own peril. Strict mode can be toggled on/off using the Toggle Paredit Mode command, and there is a status bar indicator telling you: Indicator Paredit Mode [\u03bb] Strict (\u03bb) Cave Man \u03bb No default key bindings Toggle bewteen Strict and Cave Man using: ctrl+alt+p ctrl+alt+m Commands The Paredit commands sorts into Navigation , Selection , and Edit . As mentioned, Slurp and Barf are power commands, which go into the editing category. Learning to navigate structurally, using shortcuts, also saves time and adds precision to your editing. It has the double effect that you at the same time learn how to select structurally, because that is the same, just adding the shift key. To make the command descriptions a bit clearer, each entry is animated. When you try to figure out what is going on in the GIFs, focus on where the cursor is at the start of the animation loop. Strings are not Lists, but Anyway... In Calva Paredit, strings are treated in much the same way as lists are. Here's an example showing Slurp and Barf , Forward/Backward List , and Grow Selection . Navigating (Modify these with shift to select rather than move, see below.) Default keybinding Action Description ctrl+alt+right Forward Sexp Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Will not move out of lists. ctrl+alt+left Backward Sexp Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Will not move out of lists. ctrl+down Forward Down Sexp Moves the cursor into the following list. ctrl+alt+up Backward Down Sexp Moves the cursor into the preceding list. ctrl+alt+down Forward Up Sexp Moves the cursor forwards, out of the current list. ctrl+up Backward Up Sexp Moves the cursor backwards, out of the current list. ctrl+end Forward to List End/Close Moves the cursor forwards, staying within the current list. ctrl+home Backward to List Start/Open Moves the cursor backwards, staying within the current list. Selecting Default keybinding Action Description ctrl+w Expand Selection Starts from the cursor and selects the current form. Then will keep expanding to enclosing forms. ctrl+shift+w Shrink Selection Contracts back from an expanded selection performed by any Paredit selection command. (In the animation the selection is first grown using a combination of Grow Selection and some lateral selection commands, then shrunk all the way back down to no selection.) ctrl+alt+w space Select Top Level Form Top level in a structural sence. Typically where your (def ...) / (defn ...) type forms. Please note that (comment ...) forms create a new top level. The selecting \u201dversions\u201d of the navigation commands above. They will all grow whatever current selection as far as the Shrink Selection command is concerned. Default keybinding Action Description ctrl+shift+alt+right Select Forward Sexp ctrl+shift+alt+left Select Backward Sexp ctrl+shift+down Select Forward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+up Select Backward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+down Select Forward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+up Select Backward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+end Select Forward to List End/Close ctrl+shift+home Select Backward to List Start/Open (Earlier versions of Calva had commands for copying, cutting and deleting that corresponded to all movements. This has now been replaced with this selection commands, and you can choose to copy/cut/delete once you have the selection.) Editing Default keybinding Action Description ctrl+right NB On Mac this keybinding might need your attention, see Quirks . Slurp Forward Moves the closing bracket forward , away from the cursor, past the following form, if any. ctrl+left NB On Mac this keybinding might need your attention, see Quirks . Barf Forward Moves the closing bracket backward , towards the cursor, past the preceding form. ctrl+shift+left Slurp Backward Moves the opening bracket backward , away from the cursor, past the preceding form, if any. ctrl+shift+right Barf Backward Moves the opening bracket forward , towards the cursor, past the following form. ctrl+alt+s Splice Sexp Remove enclosing brackets. ctrl+shift+s Split Sexp Splits a string, or a list, into two strings, or lists of the same type as the current. ctrl+shift+j Join Sexps/Forms Joins two strings, or two lists of the same type, into one form (string/list). ctrl+alt+p ctrl+alt+r Raise Sexp Replaces the enclosing list with the current form. ctrl+alt+t Transpose Sexps/Forms Swaps place of the two forms surrounding the cursor. ctrl+alt+shift b ctrl+alt+shift f Drag Sexp Backward/Forward Moves the current form to the behind/in front of the previous/next one. ctrl+alt+shift u ctrl+alt+shift d Drag Sexp Backward Up Drag Sexp Forward Down Moves the current form up/out of the current list, backwards , and down/in to the following list, forwards , keeping the cursor within the sexpr being dragged. ctrl+alt+shift k ctrl+alt+shift j Drag Sexp Forward Up Drag Sexp Backward Down Moves the current form up/out of the current list, forwards , and down/in to the preceding list, backwards , keeping the cursor within the sexpr being dragged. ctrl+shift+c Convolute \u00af\\_(\u30c4)_/\u00af ctrl+shift+delete Kill Sexp Forward Deletes the next form in the same enclosing form as the cursor. ctrl+alt+backspace Kill Sexp Backward Deletes the previous form in the same enclosing form as the cursor. ctrl+delete Kill List Forward Deletes everything from the cursor to the closing of the current enclosing form. ctrl+backspace Kill List Backward Deletes everything from the cursor to the opening of the current enclosing form. ctrl+alt+shift+delete Splice Killing Forward Delete forward to end of the list, then Splice. ctrl+alt+shift+backspace Splice Killing Backwards Delete backward to the start of the list, then Splice. ctrl+alt+shift+p Wrap Around () Wraps the current form, or selection, with parens. ctrl+alt+shift+s Wrap Around [] Wraps the current form, or selection, with square brackets. ctrl+alt+shift+c Wrap Around {} Wraps the current form, or selection, with curlies. ctrl+alt+shift+q Wrap Around \"\" Wraps the current form, or selection, with double quotes. Inside strings it will quote the quotes. ctrl+alt+r ctrl+alt+p / s / c / q Rewrap Changes enclosing brackets of the current form to parens/square brackets/curlies/double quotes.. About the Keyboard Shortcuts Care has been put in to making the default keybindings somewhat logical, easy to use, and work with most keyboard layouts. Slurp and barf forward are extra accessible to go with the recommendation to learn using these two super handy editing commands. Note: You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) If you add your own key bindings, please be aware that shortcuts with typable characters will work badly in the the REPL window . Please avoid. Happy Editing! \u2764\ufe0f","title":"Paredit \u2013 a Visual Guide"},{"location":"paredit/#paredit-a-visual-guide","text":"Structural editing and navigation for Clojure.","title":"Paredit \u2013 a Visual Guide"},{"location":"paredit/#what-is-paredit","text":"Calva Paredit helps you navigate, select and edit Clojure code in a structural way. LISP isn't line or character oriented, it is based around S-expressions , a.k.a forms. We strongly recommend that you take advantage of the structural nature of Clojure, and have therefore put a lot of work into making Calva Paredit extra awesome. If you are new to Paredit, consider starting with learning the Slurp Forward (pull in the next form into this form) and Barf Forward (push the last form out of this form). It will take you quite far.","title":"What is Paredit?"},{"location":"paredit/#strict-mode","text":"To protect the integrity of your code, Strict mode is enabled by default. Strict mode keybinding Action Description backspace Delete Backward Deletes one character backwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it will remove both open and close brackets. delete Delete Forward Deletes one character forwards, unless it will unbalance a form. Otherwise moves past the character instead of deleting it. If the list is empty, it is removed. alt+backspace Force Delete Backward Deletes one character backwards, even if it will unbalance a form. alt+delete Force Delete Forward Deletes one character forwards, even if it will unbalance a form. Disable at your own peril. Strict mode can be toggled on/off using the Toggle Paredit Mode command, and there is a status bar indicator telling you: Indicator Paredit Mode [\u03bb] Strict (\u03bb) Cave Man \u03bb No default key bindings Toggle bewteen Strict and Cave Man using: ctrl+alt+p ctrl+alt+m","title":"Strict Mode"},{"location":"paredit/#commands","text":"The Paredit commands sorts into Navigation , Selection , and Edit . As mentioned, Slurp and Barf are power commands, which go into the editing category. Learning to navigate structurally, using shortcuts, also saves time and adds precision to your editing. It has the double effect that you at the same time learn how to select structurally, because that is the same, just adding the shift key. To make the command descriptions a bit clearer, each entry is animated. When you try to figure out what is going on in the GIFs, focus on where the cursor is at the start of the animation loop.","title":"Commands"},{"location":"paredit/#strings-are-not-lists-but-anyway","text":"In Calva Paredit, strings are treated in much the same way as lists are. Here's an example showing Slurp and Barf , Forward/Backward List , and Grow Selection .","title":"Strings are not Lists, but Anyway..."},{"location":"paredit/#navigating","text":"(Modify these with shift to select rather than move, see below.) Default keybinding Action Description ctrl+alt+right Forward Sexp Moves the cursor forward, to the end of the current form. If at the end, moves to the end of the next form. Will not move out of lists. ctrl+alt+left Backward Sexp Moves the cursor backward, to the start of the current form. If at the start, moves to the start of the previous form. Will not move out of lists. ctrl+down Forward Down Sexp Moves the cursor into the following list. ctrl+alt+up Backward Down Sexp Moves the cursor into the preceding list. ctrl+alt+down Forward Up Sexp Moves the cursor forwards, out of the current list. ctrl+up Backward Up Sexp Moves the cursor backwards, out of the current list. ctrl+end Forward to List End/Close Moves the cursor forwards, staying within the current list. ctrl+home Backward to List Start/Open Moves the cursor backwards, staying within the current list.","title":"Navigating"},{"location":"paredit/#selecting","text":"Default keybinding Action Description ctrl+w Expand Selection Starts from the cursor and selects the current form. Then will keep expanding to enclosing forms. ctrl+shift+w Shrink Selection Contracts back from an expanded selection performed by any Paredit selection command. (In the animation the selection is first grown using a combination of Grow Selection and some lateral selection commands, then shrunk all the way back down to no selection.) ctrl+alt+w space Select Top Level Form Top level in a structural sence. Typically where your (def ...) / (defn ...) type forms. Please note that (comment ...) forms create a new top level. The selecting \u201dversions\u201d of the navigation commands above. They will all grow whatever current selection as far as the Shrink Selection command is concerned. Default keybinding Action Description ctrl+shift+alt+right Select Forward Sexp ctrl+shift+alt+left Select Backward Sexp ctrl+shift+down Select Forward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+up Select Backward Down Sexp (You probably do not need to select like this, but you can!) ctrl+shift+alt+down Select Forward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+up Select Backward Up Sexp (You probably do not need to select like this, but you can!) ctrl+shift+end Select Forward to List End/Close ctrl+shift+home Select Backward to List Start/Open (Earlier versions of Calva had commands for copying, cutting and deleting that corresponded to all movements. This has now been replaced with this selection commands, and you can choose to copy/cut/delete once you have the selection.)","title":"Selecting"},{"location":"paredit/#editing","text":"Default keybinding Action Description ctrl+right NB On Mac this keybinding might need your attention, see Quirks . Slurp Forward Moves the closing bracket forward , away from the cursor, past the following form, if any. ctrl+left NB On Mac this keybinding might need your attention, see Quirks . Barf Forward Moves the closing bracket backward , towards the cursor, past the preceding form. ctrl+shift+left Slurp Backward Moves the opening bracket backward , away from the cursor, past the preceding form, if any. ctrl+shift+right Barf Backward Moves the opening bracket forward , towards the cursor, past the following form. ctrl+alt+s Splice Sexp Remove enclosing brackets. ctrl+shift+s Split Sexp Splits a string, or a list, into two strings, or lists of the same type as the current. ctrl+shift+j Join Sexps/Forms Joins two strings, or two lists of the same type, into one form (string/list). ctrl+alt+p ctrl+alt+r Raise Sexp Replaces the enclosing list with the current form. ctrl+alt+t Transpose Sexps/Forms Swaps place of the two forms surrounding the cursor. ctrl+alt+shift b ctrl+alt+shift f Drag Sexp Backward/Forward Moves the current form to the behind/in front of the previous/next one. ctrl+alt+shift u ctrl+alt+shift d Drag Sexp Backward Up Drag Sexp Forward Down Moves the current form up/out of the current list, backwards , and down/in to the following list, forwards , keeping the cursor within the sexpr being dragged. ctrl+alt+shift k ctrl+alt+shift j Drag Sexp Forward Up Drag Sexp Backward Down Moves the current form up/out of the current list, forwards , and down/in to the preceding list, backwards , keeping the cursor within the sexpr being dragged. ctrl+shift+c Convolute \u00af\\_(\u30c4)_/\u00af ctrl+shift+delete Kill Sexp Forward Deletes the next form in the same enclosing form as the cursor. ctrl+alt+backspace Kill Sexp Backward Deletes the previous form in the same enclosing form as the cursor. ctrl+delete Kill List Forward Deletes everything from the cursor to the closing of the current enclosing form. ctrl+backspace Kill List Backward Deletes everything from the cursor to the opening of the current enclosing form. ctrl+alt+shift+delete Splice Killing Forward Delete forward to end of the list, then Splice. ctrl+alt+shift+backspace Splice Killing Backwards Delete backward to the start of the list, then Splice. ctrl+alt+shift+p Wrap Around () Wraps the current form, or selection, with parens. ctrl+alt+shift+s Wrap Around [] Wraps the current form, or selection, with square brackets. ctrl+alt+shift+c Wrap Around {} Wraps the current form, or selection, with curlies. ctrl+alt+shift+q Wrap Around \"\" Wraps the current form, or selection, with double quotes. Inside strings it will quote the quotes. ctrl+alt+r ctrl+alt+p / s / c / q Rewrap Changes enclosing brackets of the current form to parens/square brackets/curlies/double quotes..","title":"Editing"},{"location":"paredit/#about-the-keyboard-shortcuts","text":"Care has been put in to making the default keybindings somewhat logical, easy to use, and work with most keyboard layouts. Slurp and barf forward are extra accessible to go with the recommendation to learn using these two super handy editing commands. Note: You can choose to disable all default key bindings by configuring calva.paredit.defaultKeyMap to none . (Then you probably also want to register your own shortcuts for the commands you often use.) If you add your own key bindings, please be aware that shortcuts with typable characters will work badly in the the REPL window . Please avoid. Happy Editing! \u2764\ufe0f","title":"About the Keyboard Shortcuts"},{"location":"pprint/","text":"Pretty Printing In Calva, pretty printing is a mode. Prettiness is on by default and all your evaluation results will get that treatment. Toggle it There is a pprint indicator to the right in the status bar which shows the status of the mode. Click the indicator to toggle prettification on and off. There is also a Calva: Toggle Pretty Printing for All Evaluations command. Tip: If you have evaluated something time consuming, or that is not idempotent, with pretty printing mistakenly off: toggle it on and evaluate *1 . Configuration For most people the defaults will probably work, but Calva pretty printing comes a few knobs you can turn, and they are all available through the calva.prettyPrintingOptions settings. Things you can set are: Setting Type Effect enabled boolean so this is a third way you can change this mode \ud83d\ude04 printEngine enum which printer function that will be used. Default is pprint , more about this setting below width number the maximum line length of printed output (or at least the printers will try) maxLength number the maximum number of elements printed in nested nodes, good for evaluating something like (iterate inc 0) , which you shouldn't do without setting maxLength . Most printers will indicate truncated lists with ... at the end. maxDepth number the maximum number of levels deep that will get printed. Different printers mark a stop different ways. puget doesn't support it at all. See Customizing Calva for some tips on adding settings like these. Here's an example of how zprint handles maxDepth (from the Calva implementation of it's client side pretty printing.). (pretty-print [[[[[[[[:deeper]]]]]]]] {:max-depth 4}) ;; => {:value \"[[[[##]]]]\"} Your Selection of Prettifiers Pretty printing can happen on the server (i.e. in the JVM, via nREPL), or on the client (i.e. in node, via VS Code/Calva). Client side always uses zprint . Server side you can choose from these printers: Print Engine Client or Server Side Comments calva client i.e. the nREPL server will plain print the results, and then Calva will pretty it. pprint server current Calva default ( clojure.core/pprint is a bit basic, but it's tried and tested, and has none of the server side printing issues mentioned below. fipp server puget server Lacks maxDepth option. zprint server Recommended. Will need to be configured before Jack-in if you want Calva's help to inject its dependencies It is this particular selection of server side functions, because they have pre-configured print-functions in cider-nrepl . Why does Server or Client Side Matter? This matters because on the server all pretty printers, except pprint does more than just pretty print the result that would be printed with plain printing. Pretty printing results on the server causes some results to get expanded. This can have huge implications depending on the results and which printer is used. E.g. for Datomic transaction results, you will get the whole database printed. Twice. Depending on the database, you could be so unlucky that nothing gets printed, instead you will soon have a very hot computer. Note: With the help of zprint creator, Kim Kinnear , we have found ways to compensate for this problems. Ways that are not yet implemented, but please stay tuned. Then, why not always do it client side? It turns out that on the client side there are also things going on. Calva gets the results back as a string and therefore it needs to first be parsed back to EDN , before it can be pretty printed by zprint . And \u2013 here's the catch \u2013 all results are not valid EDN and therefore can't be pretty printed by zprint . Datomic transaction results are one example. Need More Configurability? The current options are limited, because our time developing Calva is limited. But cider-nrepl really allows for fully configurable pretty printing, so it is within reach. Please feel invited to give us feedback on what you would want to configure for the printing of results. File issues and/or chat us up in #calva on the Clojurians slack. Enjoy Prettiful Printing! \u2764\ufe0f","title":"Pretty Printing"},{"location":"pprint/#pretty-printing","text":"In Calva, pretty printing is a mode. Prettiness is on by default and all your evaluation results will get that treatment.","title":"Pretty Printing"},{"location":"pprint/#toggle-it","text":"There is a pprint indicator to the right in the status bar which shows the status of the mode. Click the indicator to toggle prettification on and off. There is also a Calva: Toggle Pretty Printing for All Evaluations command. Tip: If you have evaluated something time consuming, or that is not idempotent, with pretty printing mistakenly off: toggle it on and evaluate *1 .","title":"Toggle it"},{"location":"pprint/#configuration","text":"For most people the defaults will probably work, but Calva pretty printing comes a few knobs you can turn, and they are all available through the calva.prettyPrintingOptions settings. Things you can set are: Setting Type Effect enabled boolean so this is a third way you can change this mode \ud83d\ude04 printEngine enum which printer function that will be used. Default is pprint , more about this setting below width number the maximum line length of printed output (or at least the printers will try) maxLength number the maximum number of elements printed in nested nodes, good for evaluating something like (iterate inc 0) , which you shouldn't do without setting maxLength . Most printers will indicate truncated lists with ... at the end. maxDepth number the maximum number of levels deep that will get printed. Different printers mark a stop different ways. puget doesn't support it at all. See Customizing Calva for some tips on adding settings like these. Here's an example of how zprint handles maxDepth (from the Calva implementation of it's client side pretty printing.). (pretty-print [[[[[[[[:deeper]]]]]]]] {:max-depth 4}) ;; => {:value \"[[[[##]]]]\"}","title":"Configuration"},{"location":"pprint/#your-selection-of-prettifiers","text":"Pretty printing can happen on the server (i.e. in the JVM, via nREPL), or on the client (i.e. in node, via VS Code/Calva). Client side always uses zprint . Server side you can choose from these printers: Print Engine Client or Server Side Comments calva client i.e. the nREPL server will plain print the results, and then Calva will pretty it. pprint server current Calva default ( clojure.core/pprint is a bit basic, but it's tried and tested, and has none of the server side printing issues mentioned below. fipp server puget server Lacks maxDepth option. zprint server Recommended. Will need to be configured before Jack-in if you want Calva's help to inject its dependencies It is this particular selection of server side functions, because they have pre-configured print-functions in cider-nrepl .","title":"Your Selection of Prettifiers"},{"location":"pprint/#why-does-server-or-client-side-matter","text":"This matters because on the server all pretty printers, except pprint does more than just pretty print the result that would be printed with plain printing. Pretty printing results on the server causes some results to get expanded. This can have huge implications depending on the results and which printer is used. E.g. for Datomic transaction results, you will get the whole database printed. Twice. Depending on the database, you could be so unlucky that nothing gets printed, instead you will soon have a very hot computer. Note: With the help of zprint creator, Kim Kinnear , we have found ways to compensate for this problems. Ways that are not yet implemented, but please stay tuned. Then, why not always do it client side? It turns out that on the client side there are also things going on. Calva gets the results back as a string and therefore it needs to first be parsed back to EDN , before it can be pretty printed by zprint . And \u2013 here's the catch \u2013 all results are not valid EDN and therefore can't be pretty printed by zprint . Datomic transaction results are one example.","title":"Why does Server or Client Side Matter?"},{"location":"pprint/#need-more-configurability","text":"The current options are limited, because our time developing Calva is limited. But cider-nrepl really allows for fully configurable pretty printing, so it is within reach. Please feel invited to give us feedback on what you would want to configure for the printing of results. File issues and/or chat us up in #calva on the Clojurians slack. Enjoy Prettiful Printing! \u2764\ufe0f","title":"Need More Configurability?"},{"location":"quirks/","text":"Quirks Here's a shocker for ya': Calva isn't perfect. \ud83d\ude04 There are quirks and things that flat out do not work. We'll try to collect info about such things here, providing workarounds when available (or, rather, known to us). Test features not available with ClojureScript Currently cider-nrepl does not provide its test functionality for ClojureScript code. Please consider contributing to fixing that. Using with Parinfer Calva defaults to formatting as you type. If you use Parinfer this creates a conflict, since it auto-indents your code. If you want to use Parinfer you'll have to tell Calva not to do auto-formatting by disabling calva.fmt.formatAsYouType . However, with VS Code and Calva it is probably better to learn to use Paredit 's slurp and barf and generally use Calva's automatic formatting. MacOS and the Slurp and Barf Keyboard Shortcuts To make slurping and barfing forward really easy to perform they are bound to ctrl+right and ctrl+left , respectively. However on MacOS those shortcuts are sometimes bound by Mission Control, causing the Calva shortcuts to not work. One way to solve it is to disable the shortcuts in System Preferences -> Keyboard -> Shortcuts : Calva and the VIM Extension See Using Calva with the VIM Extension . \u201dCommand not found\u201d errors on Jack-in Jack-in starts by spawning of a command in the shell. You will need the commands used installed on your computer: clojure for tools.deps/Clojure CLI lein for Leiningen npx for shadow-cljs Also, in some circumstances VS Code is not spawned from a shell with the environment variables, expecially $PATH , which might mean that even though you have the tools installed, they are not found when VS Code/Calva tries to execute them. To fix this you will need to do one of these two things: Figure out from where VS Code is spawned, and make sure the $PATH there includes the directoy with the needed binary. Start VS Code from a terminal where the $PATH is correctly configured. (Using the code commmand.) See this issue for more clues on this problem. Strange linting errors? This is not really a quirk, and most linting errors are not strange when you learn about why they are there. Calva does not do any linting, btw, see also linting .","title":"Quirks"},{"location":"quirks/#quirks","text":"Here's a shocker for ya': Calva isn't perfect. \ud83d\ude04 There are quirks and things that flat out do not work. We'll try to collect info about such things here, providing workarounds when available (or, rather, known to us).","title":"Quirks"},{"location":"quirks/#test-features-not-available-with-clojurescript","text":"Currently cider-nrepl does not provide its test functionality for ClojureScript code. Please consider contributing to fixing that.","title":"Test features not available with ClojureScript"},{"location":"quirks/#using-with-parinfer","text":"Calva defaults to formatting as you type. If you use Parinfer this creates a conflict, since it auto-indents your code. If you want to use Parinfer you'll have to tell Calva not to do auto-formatting by disabling calva.fmt.formatAsYouType . However, with VS Code and Calva it is probably better to learn to use Paredit 's slurp and barf and generally use Calva's automatic formatting.","title":"Using with Parinfer"},{"location":"quirks/#macos-and-the-slurp-and-barf-keyboard-shortcuts","text":"To make slurping and barfing forward really easy to perform they are bound to ctrl+right and ctrl+left , respectively. However on MacOS those shortcuts are sometimes bound by Mission Control, causing the Calva shortcuts to not work. One way to solve it is to disable the shortcuts in System Preferences -> Keyboard -> Shortcuts :","title":"MacOS and the Slurp and Barf Keyboard Shortcuts"},{"location":"quirks/#calva-and-the-vim-extension","text":"See Using Calva with the VIM Extension .","title":"Calva and the VIM Extension"},{"location":"quirks/#command-not-found-errors-on-jack-in","text":"Jack-in starts by spawning of a command in the shell. You will need the commands used installed on your computer: clojure for tools.deps/Clojure CLI lein for Leiningen npx for shadow-cljs Also, in some circumstances VS Code is not spawned from a shell with the environment variables, expecially $PATH , which might mean that even though you have the tools installed, they are not found when VS Code/Calva tries to execute them. To fix this you will need to do one of these two things: Figure out from where VS Code is spawned, and make sure the $PATH there includes the directoy with the needed binary. Start VS Code from a terminal where the $PATH is correctly configured. (Using the code commmand.) See this issue for more clues on this problem.","title":"\u201dCommand not found\u201d errors on Jack-in"},{"location":"quirks/#strange-linting-errors","text":"This is not really a quirk, and most linting errors are not strange when you learn about why they are there. Calva does not do any linting, btw, see also linting .","title":"Strange linting errors?"},{"location":"rebl/","text":"How to Use Calva and REBL Together REBL is a graphical, interactive tool for browsing Clojure data. Clojure CLI Add your aliases to your deps.edn file. Use the deps.edn file in the ~/.clojure directory to enable alias reuse across multiple projects. Add the REBL and nREBL aliases to your deps.edn file. Below is the configuration for REBL on openjdk 12 ;; REBL Base :rebl {:extra-deps {org.clojure/core.async {:mvn/version \"0.4.490\"} ;; deps for file datafication (0.9.149 or later) org.clojure/data.csv {:mvn/version \"0.1.4\"} org.clojure/data.json {:mvn/version \"0.2.3\"} org.yaml/snakeyaml {:mvn/version \"1.23\"} com.cognitect/rebl ;; adjust to match your install location {:local/root \"/Users/ozimos/REBL/latest/REBL.jar\"}}} ;; REBL 12 :rebl-12 {:extra-deps {org.openjfx/javafx-fxml {:mvn/version \"12.0.1\"} org.openjfx/javafx-controls {:mvn/version \"12.0.1\"} org.openjfx/javafx-graphics {:mvn/version \"12.0.1\"} org.openjfx/javafx-media {:mvn/version \"12.0.1\"} org.openjfx/javafx-swing {:mvn/version \"12.0.1\"} org.openjfx/javafx-base {:mvn/version \"12.0.1\"} org.openjfx/javafx-web {:mvn/version \"12.0.1\"}}} ;; nREBL :nrebl {:extra-deps {rickmoynihan/nrebl.middleware {:mvn/version \"0.2.0\"}} :main-opts [\"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl]\" \"-I\"]} Check out the REBL github page for more info Create a Calva custom connect sequence for your VSCode editor Read Custom REPL Connect Sequences if you haven't Add the following to your vscode settings.json { \"calva.replConnectSequences\": [ { \"name\": \"Rebl Connect\", \"projectType\": \"Clojure CLI\", \"menuSelections\": { \"cljAliases\": [ \"rebl\", \"rebl-12\", \"nrebl\" ] } } ] } Leiningen Add rebl profiles to your user-wide profiles so that they will be available for all your projects. A sample user profile (located at ~/.lein/profiles.clj on mac) {:user {:plugins [[lein-ancient \"0.6.15\"]]} ;; REBL Base :rebl {:resource-paths [\"/Users/ozimos/REBL/latest/REBL.jar\"] :dependencies [[org.clojure/core.async \"0.4.490\"] [org.clojure/data.csv \"0.1.4\"] [org.clojure/data.json \"0.2.3\"] [cljfmt \"0.6.4\"] [org.yaml/snakeyaml \"1.23\"]]} ;; REBL 12 for JDK 12.0.1. Swap out for your JDK vaersion :rebl-12 {:dependencies [[org.openjfx/javafx-fxml \"12.0.1\"] [org.openjfx/javafx-controls \"12.0.1\"] [org.openjfx/javafx-graphics \"12.0.1\"] [org.openjfx/javafx-media \"12.0.1\"] [org.openjfx/javafx-swing \"12.0.1\"] [org.openjfx/javafx-base \"12.0.1\"] [org.openjfx/javafx-web \"12.0.1\"]]} ;; NREBL https://github.com/RickMoynihan/nrebl.middleware :nrebl {:repl-options {:nrepl-middleware [nrebl.middleware/wrap-nrebl]} :dependencies [[rickmoynihan/nrebl.middleware \"0.3.1\"]]}} More info here Create a Calva custom connect sequence for your VSCode editor Read Custom REPL Connect Sequences if you haven't Add the following to your vscode settings.json { \"calva.replConnectSequences\": [ { \"name\": \"Lein REBL\", \"projectType\": \"Leiningen\", \"menuSelections\": { \"leinProfiles\": [\"rebl\", \"rebl-12\", \":nrebl\"] }, \"afterCLJReplJackInCode\": \"((requiring-resolve 'cognitect.rebl/ui))\" } ] } shadow-cljs (TBD) TBD. If you know how to do it, please update this page.","title":"How to Use Calva and REBL Together"},{"location":"rebl/#how-to-use-calva-and-rebl-together","text":"REBL is a graphical, interactive tool for browsing Clojure data.","title":"How to Use Calva and REBL Together"},{"location":"rebl/#clojure-cli","text":"Add your aliases to your deps.edn file. Use the deps.edn file in the ~/.clojure directory to enable alias reuse across multiple projects. Add the REBL and nREBL aliases to your deps.edn file. Below is the configuration for REBL on openjdk 12 ;; REBL Base :rebl {:extra-deps {org.clojure/core.async {:mvn/version \"0.4.490\"} ;; deps for file datafication (0.9.149 or later) org.clojure/data.csv {:mvn/version \"0.1.4\"} org.clojure/data.json {:mvn/version \"0.2.3\"} org.yaml/snakeyaml {:mvn/version \"1.23\"} com.cognitect/rebl ;; adjust to match your install location {:local/root \"/Users/ozimos/REBL/latest/REBL.jar\"}}} ;; REBL 12 :rebl-12 {:extra-deps {org.openjfx/javafx-fxml {:mvn/version \"12.0.1\"} org.openjfx/javafx-controls {:mvn/version \"12.0.1\"} org.openjfx/javafx-graphics {:mvn/version \"12.0.1\"} org.openjfx/javafx-media {:mvn/version \"12.0.1\"} org.openjfx/javafx-swing {:mvn/version \"12.0.1\"} org.openjfx/javafx-base {:mvn/version \"12.0.1\"} org.openjfx/javafx-web {:mvn/version \"12.0.1\"}}} ;; nREBL :nrebl {:extra-deps {rickmoynihan/nrebl.middleware {:mvn/version \"0.2.0\"}} :main-opts [\"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl]\" \"-I\"]} Check out the REBL github page for more info Create a Calva custom connect sequence for your VSCode editor Read Custom REPL Connect Sequences if you haven't Add the following to your vscode settings.json { \"calva.replConnectSequences\": [ { \"name\": \"Rebl Connect\", \"projectType\": \"Clojure CLI\", \"menuSelections\": { \"cljAliases\": [ \"rebl\", \"rebl-12\", \"nrebl\" ] } } ] }","title":"Clojure CLI"},{"location":"rebl/#leiningen","text":"Add rebl profiles to your user-wide profiles so that they will be available for all your projects. A sample user profile (located at ~/.lein/profiles.clj on mac) {:user {:plugins [[lein-ancient \"0.6.15\"]]} ;; REBL Base :rebl {:resource-paths [\"/Users/ozimos/REBL/latest/REBL.jar\"] :dependencies [[org.clojure/core.async \"0.4.490\"] [org.clojure/data.csv \"0.1.4\"] [org.clojure/data.json \"0.2.3\"] [cljfmt \"0.6.4\"] [org.yaml/snakeyaml \"1.23\"]]} ;; REBL 12 for JDK 12.0.1. Swap out for your JDK vaersion :rebl-12 {:dependencies [[org.openjfx/javafx-fxml \"12.0.1\"] [org.openjfx/javafx-controls \"12.0.1\"] [org.openjfx/javafx-graphics \"12.0.1\"] [org.openjfx/javafx-media \"12.0.1\"] [org.openjfx/javafx-swing \"12.0.1\"] [org.openjfx/javafx-base \"12.0.1\"] [org.openjfx/javafx-web \"12.0.1\"]]} ;; NREBL https://github.com/RickMoynihan/nrebl.middleware :nrebl {:repl-options {:nrepl-middleware [nrebl.middleware/wrap-nrebl]} :dependencies [[rickmoynihan/nrebl.middleware \"0.3.1\"]]}} More info here Create a Calva custom connect sequence for your VSCode editor Read Custom REPL Connect Sequences if you haven't Add the following to your vscode settings.json { \"calva.replConnectSequences\": [ { \"name\": \"Lein REBL\", \"projectType\": \"Leiningen\", \"menuSelections\": { \"leinProfiles\": [\"rebl\", \"rebl-12\", \":nrebl\"] }, \"afterCLJReplJackInCode\": \"((requiring-resolve 'cognitect.rebl/ui))\" } ] }","title":"Leiningen"},{"location":"rebl/#shadow-cljs-tbd","text":"TBD. If you know how to do it, please update this page.","title":"shadow-cljs (TBD)"},{"location":"remote-development/","text":"Using Calva with Remote Development VS Code Remote Development is a new feature in version 1.35 of VS Code that allows a developer to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. I would recommend reading the introductory blog post and watching the videos. I find the feature extremely exciting and wish more IDEs would implement something like it. From a Clojure perspective it allows you to have VS Code installed on your Java-less, Clojure-less hardware and still use it to develop Clojure through it. A use-case for some reason your physical computer has to be running Windows (organisational rules etc.) your deployment environment is Linux you want to edit files in an editor running on your physical computer most Clojure tooling is made with *nix first in mind and there are incompatibilities with Windows WSL See Using Calva with WSL","title":"Using Calva with Remote Development"},{"location":"remote-development/#using-calva-with-remote-development","text":"VS Code Remote Development is a new feature in version 1.35 of VS Code that allows a developer to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. I would recommend reading the introductory blog post and watching the videos. I find the feature extremely exciting and wish more IDEs would implement something like it. From a Clojure perspective it allows you to have VS Code installed on your Java-less, Clojure-less hardware and still use it to develop Clojure through it.","title":"Using Calva with Remote Development"},{"location":"remote-development/#a-use-case","text":"for some reason your physical computer has to be running Windows (organisational rules etc.) your deployment environment is Linux you want to edit files in an editor running on your physical computer most Clojure tooling is made with *nix first in mind and there are incompatibilities with Windows","title":"A use-case"},{"location":"remote-development/#wsl","text":"See Using Calva with WSL","title":"WSL"},{"location":"try-first/","text":"Something to Try First (After Connecting) You might want to start with evaluating some code. This preferably starts with Loading Current File and Dependencies , ctrl+alt+c enter . Then... Calva has this notion about the \u201dcurrent\u201d form. Issue the Evaluate Current Form Inline command, ctrl+alt+c e ( ctrl+alt+c v on Windows) with the cursor placed in different locations to get a feeling for how the current form is determined. Dismiss the results display with esc . There is also a command for evaluating the current top level form. Good for evaluating various def s defn , defthis , defthat . With your cursor placed anywhere inside such a form, issue the Evaluate Current Top Level Form (defun) command ( ctrl+alt+c space ). The Top Level command also works inside (comment ...) forms, treating the comment as creating a new top level context. It is good for in-file code experimentation. To use it place the cursor inside a form contained inside a (comment...) and issue the command from there. It looks something like so: See also * Calva Top 10 Commands . * Code Evaluation Tips","title":"Something to Try First (After Connecting)"},{"location":"try-first/#something-to-try-first-after-connecting","text":"You might want to start with evaluating some code. This preferably starts with Loading Current File and Dependencies , ctrl+alt+c enter . Then... Calva has this notion about the \u201dcurrent\u201d form. Issue the Evaluate Current Form Inline command, ctrl+alt+c e ( ctrl+alt+c v on Windows) with the cursor placed in different locations to get a feeling for how the current form is determined. Dismiss the results display with esc . There is also a command for evaluating the current top level form. Good for evaluating various def s defn , defthis , defthat . With your cursor placed anywhere inside such a form, issue the Evaluate Current Top Level Form (defun) command ( ctrl+alt+c space ). The Top Level command also works inside (comment ...) forms, treating the comment as creating a new top level context. It is good for in-file code experimentation. To use it place the cursor inside a form contained inside a (comment...) and issue the command from there. It looks something like so: See also * Calva Top 10 Commands . * Code Evaluation Tips","title":"Something to Try First (After Connecting)"},{"location":"using-with/","text":"Using Calva with X Calva can be used in conjunction with many other Clojure related technologies and projects. Please consider contributing with guides about how you have set things up to achieve your workflow with this or that awesome thing. .. toctree:: :maxdepth: 3 :caption: Contents: rebl vim wsl remote-development luminus","title":"Using Calva with X"},{"location":"using-with/#using-calva-with-x","text":"Calva can be used in conjunction with many other Clojure related technologies and projects. Please consider contributing with guides about how you have set things up to achieve your workflow with this or that awesome thing. .. toctree:: :maxdepth: 3 :caption: Contents: rebl vim wsl remote-development luminus","title":"Using Calva with X"},{"location":"vim/","text":"Calva and the VIM Extension First thing first. The VIM Extension and Calva has some friction between them. Expect it to be a bit painful. Selection commands Calva's various structural selection commands do not put VIM into VISUAL mode . This is true for many VS Code selection scenarios too, so it is not really Calva's fault, but it will be problematic for VIM Extension Calva users, regardless. Key bindings In general Calva's default key bindings are not very VI-ish. This is a call for someone to share their VIM re-mappings . Expand selection Calva binds expand selection to ctrl+w . This conflicts with the VIM Extension's default mapping of window splitting shortcuts. You'll need to remap it either with Calva or with the VIM Extension. The esc key Calva binds the esc key to dismiss the display of inline results. This gets into conflict with any vi coding since esc then is used to go back to command mode. You can either fix Calva's default keybinding or the VIM extension. Alternatively, you can use the native Vim command Ctrl + [ to escape and get back to command mode. Rebinding your keyboard's CapsLock key to Control may make this even easier. Remap Calva's clearInlineResults Open the Keyboard Shortcuts JSON file from the Command Palette Disable clearInlineResults and remap the command e.g. // Place your key bindings in this file to override the defaults [ { \"key\": \"escape\", \"command\": \"-calva.clearInlineResults\" }, { \"key\": \"shift+escape\", \"command\": \"calva.clearInlineResults\", \"when\": \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" }, ] If you run into issues, refer to the commands in the default Keyboard Shortcuts JSON file. Remap Vim's Insert Mode Remap vim's insert mode keybinding to go into command mode by adding the following to your user settings: \"vim.insertModeKeyBindings\": [ { \"before\": [\"j\", \"k\"], \"after\": [\"<esc>\"] } ] (Change before to whatever keybinding you are comfortable with!) No Vim mode for the REPL Window This is not likely to be fixed anytime soon. (Because, a lot of work.)","title":"Calva and the VIM Extension"},{"location":"vim/#calva-and-the-vim-extension","text":"First thing first. The VIM Extension and Calva has some friction between them. Expect it to be a bit painful.","title":"Calva and the VIM Extension"},{"location":"vim/#selection-commands","text":"Calva's various structural selection commands do not put VIM into VISUAL mode . This is true for many VS Code selection scenarios too, so it is not really Calva's fault, but it will be problematic for VIM Extension Calva users, regardless.","title":"Selection commands"},{"location":"vim/#key-bindings","text":"In general Calva's default key bindings are not very VI-ish. This is a call for someone to share their VIM re-mappings .","title":"Key bindings"},{"location":"vim/#expand-selection","text":"Calva binds expand selection to ctrl+w . This conflicts with the VIM Extension's default mapping of window splitting shortcuts. You'll need to remap it either with Calva or with the VIM Extension.","title":"Expand selection"},{"location":"vim/#the-esc-key","text":"Calva binds the esc key to dismiss the display of inline results. This gets into conflict with any vi coding since esc then is used to go back to command mode. You can either fix Calva's default keybinding or the VIM extension. Alternatively, you can use the native Vim command Ctrl + [ to escape and get back to command mode. Rebinding your keyboard's CapsLock key to Control may make this even easier.","title":"The esc key"},{"location":"vim/#remap-calvas-clearinlineresults","text":"Open the Keyboard Shortcuts JSON file from the Command Palette Disable clearInlineResults and remap the command e.g. // Place your key bindings in this file to override the defaults [ { \"key\": \"escape\", \"command\": \"-calva.clearInlineResults\" }, { \"key\": \"shift+escape\", \"command\": \"calva.clearInlineResults\", \"when\": \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" }, ] If you run into issues, refer to the commands in the default Keyboard Shortcuts JSON file.","title":"Remap Calva's clearInlineResults"},{"location":"vim/#remap-vims-insert-mode","text":"Remap vim's insert mode keybinding to go into command mode by adding the following to your user settings: \"vim.insertModeKeyBindings\": [ { \"before\": [\"j\", \"k\"], \"after\": [\"<esc>\"] } ] (Change before to whatever keybinding you are comfortable with!)","title":"Remap Vim's Insert Mode"},{"location":"vim/#no-vim-mode-for-the-repl-window","text":"This is not likely to be fixed anytime soon. (Because, a lot of work.)","title":"No Vim mode for the REPL Window"},{"location":"workspace-layouts/","text":"Workspace layouts Project directory layouts can vary quite a lot. From the \u201dtemplate\u201d projects where the Clojure project files are at the root, to, well, let's just say that the project files are not always at the root. And sometimes there is more than one project. Calva only really supports working with one project at a time per VS Code window. Here's a short guide for some different setups: You have one project in the workspace, the project files are in there somewhere. Use a regular VS Code \u201dfolder window\u201d or a Workspace proper, both will totally work. You have more than one project in the repository, but only really work with one at a tine. Use a Workplace proper and add the different project directories as seperate Workplace Folders. You can only jack-in/connect to one project at a time. You have more than one project in the repository, and need to work with them in parallell. Open each project you want to work with in a separate VS Code window. One Folder - Two Windows? As is mentioned in the Calva Jack-In Guide , if you have a full stack project using a Clojure backend and a shadow-cljs frontend, you will need to open the same project in two separate VS Code windows, one for the backend and one for the frontend. This is how you can do that: Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Server.code-workspace . Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Client.code-workspace . Now, whenever you want to Jack-in to the backend and/or frontend, do it from the Server and/or Client workspace, respectively.","title":"Workspace layouts"},{"location":"workspace-layouts/#workspace-layouts","text":"Project directory layouts can vary quite a lot. From the \u201dtemplate\u201d projects where the Clojure project files are at the root, to, well, let's just say that the project files are not always at the root. And sometimes there is more than one project. Calva only really supports working with one project at a time per VS Code window. Here's a short guide for some different setups: You have one project in the workspace, the project files are in there somewhere. Use a regular VS Code \u201dfolder window\u201d or a Workspace proper, both will totally work. You have more than one project in the repository, but only really work with one at a tine. Use a Workplace proper and add the different project directories as seperate Workplace Folders. You can only jack-in/connect to one project at a time. You have more than one project in the repository, and need to work with them in parallell. Open each project you want to work with in a separate VS Code window.","title":"Workspace layouts"},{"location":"workspace-layouts/#one-folder-two-windows","text":"As is mentioned in the Calva Jack-In Guide , if you have a full stack project using a Clojure backend and a shadow-cljs frontend, you will need to open the same project in two separate VS Code windows, one for the backend and one for the frontend. This is how you can do that: Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Server.code-workspace . Open a new VS Code window. Select File->Add Folder to Workspace... . Save the workspace as, say, Client.code-workspace . Now, whenever you want to Jack-in to the backend and/or frontend, do it from the Server and/or Client workspace, respectively.","title":"One Folder - Two Windows?"},{"location":"wsl/","text":"Calva \u2764\ufe0f WSL The use of Calva with WSL (Windows Subsystem for Linux) is fully supported through the Remote - WSL extension. Simply install the extension an open your project with one of the Remote-WSL commands. Calva will run directly in the WSL environment and no further configuration is required. Steps Involved Enable WSL Install Ubuntu in WSL Install Java in WSL Install latest Clojure in WSL Install the Remote - WSL extension in VS Code Launch remote window Install Calva (gets installed into the WSL instance) Work away See also Remote Development .","title":"Calva \u2764\ufe0f WSL"},{"location":"wsl/#calva-wsl","text":"The use of Calva with WSL (Windows Subsystem for Linux) is fully supported through the Remote - WSL extension. Simply install the extension an open your project with one of the Remote-WSL commands. Calva will run directly in the WSL environment and no further configuration is required.","title":"Calva \u2764\ufe0f WSL"},{"location":"wsl/#steps-involved","text":"Enable WSL Install Ubuntu in WSL Install Java in WSL Install latest Clojure in WSL Install the Remote - WSL extension in VS Code Launch remote window Install Calva (gets installed into the WSL instance) Work away See also Remote Development .","title":"Steps Involved"}]}